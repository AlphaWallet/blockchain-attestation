{"version":3,"file":"bundle.js","sources":["../node_modules/rollup-plugin-node-globals/src/global.js","../node_modules/buffer-es6/base64.js","../node_modules/buffer-es6/ieee754.js","../node_modules/buffer-es6/isArray.js","../node_modules/buffer-es6/index.js","../node_modules/pvutils/src/utils.js","../node_modules/asn1js/build/asn1.js","../src/ticket_schema/algorithm_identifier.js","../src/ticket_schema/ticket_schema.js","../src/decoder.js","../src/main.js"],"sourcesContent":["export default (typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {});\n","\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\nvar inited = false;\nfunction init () {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i]\n    revLookup[code.charCodeAt(i)] = i\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n}\n\nexport function toByteArray (b64) {\n  if (!inited) {\n    init();\n  }\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nexport function fromByteArray (uint8) {\n  if (!inited) {\n    init();\n  }\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","\nexport function read (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexport function write (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nexport default Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\nimport * as base64 from './base64'\nimport * as ieee754 from './ieee754'\nimport isArray from './isArray'\n\nexport var INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : true\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nvar _kMaxLength = kMaxLength()\nexport {_kMaxLength as kMaxLength};\nfunction typedArraySupport () {\n  return true;\n  // rollup issues\n  // try {\n  //   var arr = new Uint8Array(1)\n  //   arr.__proto__ = {\n  //     __proto__: Uint8Array.prototype,\n  //     foo: function () { return 42 }\n  //   }\n  //   return arr.foo() === 42 && // typed array instances can be augmented\n  //       typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n  //       arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  // } catch (e) {\n  //   return false\n  // }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nexport function Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    // Object.defineProperty(Buffer, Symbol.species, {\n    //   value: null,\n    //   configurable: true\n    // })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nexport function SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (internalIsBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = internalIsBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n\n// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nexport function isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))\n}\n\nfunction isFastBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))\n}\n","//**************************************************************************************\r\n/**\r\n * Making UTC date from local date\r\n * @param {Date} date Date to convert from\r\n * @returns {Date}\r\n */\r\nexport function getUTCDate(date)\r\n{\r\n\t// noinspection NestedFunctionCallJS, MagicNumberJS\r\n\treturn new Date(date.getTime() + (date.getTimezoneOffset() * 60000));\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Get value for input parameters, or set a default value\r\n * @param {Object} parameters\r\n * @param {string} name\r\n * @param defaultValue\r\n */\r\nexport function getParametersValue(parameters, name, defaultValue)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tif((parameters instanceof Object) === false)\r\n\t\treturn defaultValue;\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(name in parameters)\r\n\t\treturn parameters[name];\r\n\t\r\n\treturn defaultValue;\r\n}\r\n//**************************************************************************************\r\n/**\r\n * Converts \"ArrayBuffer\" into a hexdecimal string\r\n * @param {ArrayBuffer} inputBuffer\r\n * @param {number} [inputOffset=0]\r\n * @param {number} [inputLength=inputBuffer.byteLength]\r\n * @param {boolean} [insertSpace=false]\r\n * @returns {string}\r\n */\r\nexport function bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = (inputBuffer.byteLength - inputOffset), insertSpace = false)\r\n{\r\n\tlet result = \"\";\r\n\t\r\n\tfor(const item of (new Uint8Array(inputBuffer, inputOffset, inputLength)))\r\n\t{\r\n\t\t// noinspection ChainedFunctionCallJS\r\n\t\tconst str = item.toString(16).toUpperCase();\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\t\tif(str.length === 1)\r\n\t\t\tresult += \"0\";\r\n\t\t\r\n\t\tresult += str;\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(insertSpace)\r\n\t\t\tresult += \" \";\r\n\t}\r\n\t\r\n\treturn result.trim();\r\n}\r\n//**************************************************************************************\r\n// noinspection JSValidateJSDoc, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Check input \"ArrayBuffer\" for common functions\r\n * @param {LocalBaseBlock} baseBlock\r\n * @param {ArrayBuffer} inputBuffer\r\n * @param {number} inputOffset\r\n * @param {number} inputLength\r\n * @returns {boolean}\r\n */\r\nexport function checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif((inputBuffer instanceof ArrayBuffer) === false)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputBuffer must be \\\"ArrayBuffer\\\"\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputBuffer.byteLength === 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputOffset < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(inputLength < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif((inputBuffer.byteLength - inputOffset - inputLength) < 0)\r\n\t{\r\n\t\t// noinspection JSUndefinedPropertyAssignment\r\n\t\tbaseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Convert number from 2^base to 2^10\r\n * @param {Uint8Array} inputBuffer\r\n * @param {number} inputBase\r\n * @returns {number}\r\n */\r\nexport function utilFromBase(inputBuffer, inputBase)\r\n{\r\n\tlet result = 0;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tif(inputBuffer.length === 1)\r\n\t\treturn inputBuffer[0];\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS\r\n\tfor(let i = (inputBuffer.length - 1); i >= 0; i--)\r\n\t\tresult += inputBuffer[(inputBuffer.length - 1) - i] * Math.pow(2, inputBase * i);\r\n\t\r\n\treturn result;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Convert number from 2^10 to 2^base\r\n * @param {!number} value The number to convert\r\n * @param {!number} base The base for 2^base\r\n * @param {number} [reserved=0] Pre-defined number of bytes in output array (-1 = limited by function itself)\r\n * @returns {ArrayBuffer}\r\n */\r\nexport function utilToBase(value, base, reserved = (-1))\r\n{\r\n\tconst internalReserved = reserved;\r\n\tlet internalValue = value;\r\n\t\r\n\tlet result = 0;\r\n\tlet biggest = Math.pow(2, base);\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tfor(let i = 1; i < 8; i++)\r\n\t{\r\n\t\tif(value < biggest)\r\n\t\t{\r\n\t\t\tlet retBuf;\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(internalReserved < 0)\r\n\t\t\t{\r\n\t\t\t\tretBuf = new ArrayBuffer(i);\r\n\t\t\t\tresult = i;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tif(internalReserved < i)\r\n\t\t\t\t\treturn (new ArrayBuffer(0));\r\n\t\t\t\t\r\n\t\t\t\tretBuf = new ArrayBuffer(internalReserved);\r\n\t\t\t\t\r\n\t\t\t\tresult = internalReserved;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst retView = new Uint8Array(retBuf);\r\n\t\t\t\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tfor(let j = (i - 1); j >= 0; j--)\r\n\t\t\t{\r\n\t\t\t\tconst basis = Math.pow(2, j * base);\r\n\t\t\t\t\r\n\t\t\t\tretView[result - j - 1] = Math.floor(internalValue / basis);\r\n\t\t\t\tinternalValue -= (retView[result - j - 1]) * basis;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\t\t\r\n\t\tbiggest *= Math.pow(2, base);\r\n\t}\r\n\t\r\n\treturn new ArrayBuffer(0);\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Concatenate two ArrayBuffers\r\n * @param {...ArrayBuffer} buffers Set of ArrayBuffer\r\n */\r\nexport function utilConcatBuf(...buffers)\r\n{\r\n\t//region Initial variables\r\n\tlet outputLength = 0;\r\n\tlet prevLength = 0;\r\n\t//endregion\r\n\t\r\n\t//region Calculate output length\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const buffer of buffers)\r\n\t\toutputLength += buffer.byteLength;\r\n\t//endregion\r\n\t\r\n\tconst retBuf = new ArrayBuffer(outputLength);\r\n\tconst retView = new Uint8Array(retBuf);\r\n\t\r\n\tfor(const buffer of buffers)\r\n\t{\r\n\t\t// noinspection NestedFunctionCallJS\r\n\t\tretView.set(new Uint8Array(buffer), prevLength);\r\n\t\tprevLength += buffer.byteLength;\r\n\t}\r\n\t\r\n\treturn retBuf;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Concatenate two Uint8Array\r\n * @param {...Uint8Array} views Set of Uint8Array\r\n */\r\nexport function utilConcatView(...views)\r\n{\r\n\t//region Initial variables\r\n\tlet outputLength = 0;\r\n\tlet prevLength = 0;\r\n\t//endregion\r\n\t\r\n\t//region Calculate output length\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const view of views)\r\n\t\toutputLength += view.length;\r\n\t//endregion\r\n\t\r\n\tconst retBuf = new ArrayBuffer(outputLength);\r\n\tconst retView = new Uint8Array(retBuf);\r\n\t\r\n\tfor(const view of views)\r\n\t{\r\n\t\tretView.set(view, prevLength);\r\n\t\tprevLength += view.length;\r\n\t}\r\n\t\r\n\treturn retView;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS\r\n/**\r\n * Decoding of \"two complement\" values\r\n * The function must be called in scope of instance of \"hexBlock\" class (\"valueHex\" and \"warnings\" properties must be present)\r\n * @returns {number}\r\n */\r\nexport function utilDecodeTC()\r\n{\r\n\tconst buf = new Uint8Array(this.valueHex);\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tif(this.valueHex.byteLength >= 2)\r\n\t{\r\n\t\t//noinspection JSBitwiseOperatorUsage, ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst condition1 = (buf[0] === 0xFF) && (buf[1] & 0x80);\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst condition2 = (buf[0] === 0x00) && ((buf[1] & 0x80) === 0x00);\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(condition1 || condition2)\r\n\t\t\tthis.warnings.push(\"Needlessly long format\");\r\n\t}\r\n\t\r\n\t//region Create big part of the integer\r\n\tconst bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n\tconst bigIntView = new Uint8Array(bigIntBuffer);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < this.valueHex.byteLength; i++)\r\n\t\tbigIntView[i] = 0;\r\n\t\r\n\t// noinspection MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\tbigIntView[0] = (buf[0] & 0x80); // mask only the biggest bit\r\n\t\r\n\tconst bigInt = utilFromBase(bigIntView, 8);\r\n\t//endregion\r\n\t\r\n\t//region Create small part of the integer\r\n\tconst smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\r\n\tconst smallIntView = new Uint8Array(smallIntBuffer);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let j = 0; j < this.valueHex.byteLength; j++)\r\n\t\tsmallIntView[j] = buf[j];\r\n\t\r\n\t// noinspection MagicNumberJS\r\n\tsmallIntView[0] &= 0x7F; // mask biggest bit\r\n\t\r\n\tconst smallInt = utilFromBase(smallIntView, 8);\r\n\t//endregion\r\n\t\r\n\treturn (smallInt - bigInt);\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Encode integer value to \"two complement\" format\r\n * @param {number} value Value to encode\r\n * @returns {ArrayBuffer}\r\n */\r\nexport function utilEncodeTC(value)\r\n{\r\n\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS\r\n\tconst modValue = (value < 0) ? (value * (-1)) : value;\r\n\tlet bigInt = 128;\r\n\t\r\n\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\tfor(let i = 1; i < 8; i++)\r\n\t{\r\n\t\tif(modValue <= bigInt)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(value < 0)\r\n\t\t\t{\r\n\t\t\t\tconst smallInt = bigInt - modValue;\r\n\t\t\t\t\r\n\t\t\t\tconst retBuf = utilToBase(smallInt, 8, i);\r\n\t\t\t\tconst retView = new Uint8Array(retBuf);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tretView[0] |= 0x80;\r\n\t\t\t\t\r\n\t\t\t\treturn retBuf;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tlet retBuf = utilToBase(modValue, 8, i);\r\n\t\t\tlet retView = new Uint8Array(retBuf);\r\n\t\t\t\r\n\t\t\t//noinspection JSBitwiseOperatorUsage, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\t\tif(retView[0] & 0x80)\r\n\t\t\t{\r\n\t\t\t\t//noinspection JSCheckFunctionSignatures\r\n\t\t\t\tconst tempBuf = retBuf.slice(0);\r\n\t\t\t\tconst tempView = new Uint8Array(tempBuf);\r\n\t\t\t\t\r\n\t\t\t\tretBuf = new ArrayBuffer(retBuf.byteLength + 1);\r\n\t\t\t\t// noinspection ReuseOfLocalVariableJS\r\n\t\t\t\tretView = new Uint8Array(retBuf);\r\n\t\t\t\t\r\n\t\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\t\tfor(let k = 0; k < tempBuf.byteLength; k++)\r\n\t\t\t\t\tretView[k + 1] = tempView[k];\r\n\t\t\t\t\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tretView[0] = 0x00;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn retBuf;\r\n\t\t}\r\n\t\t\r\n\t\tbigInt *= Math.pow(2, 8);\r\n\t}\r\n\t\r\n\treturn (new ArrayBuffer(0));\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS, ParameterNamingConventionJS\r\n/**\r\n * Compare two array buffers\r\n * @param {!ArrayBuffer} inputBuffer1\r\n * @param {!ArrayBuffer} inputBuffer2\r\n * @returns {boolean}\r\n */\r\nexport function isEqualBuffer(inputBuffer1, inputBuffer2)\r\n{\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(inputBuffer1.byteLength !== inputBuffer2.byteLength)\r\n\t\treturn false;\r\n\t\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tconst view1 = new Uint8Array(inputBuffer1);\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tconst view2 = new Uint8Array(inputBuffer2);\r\n\t\r\n\tfor(let i = 0; i < view1.length; i++)\r\n\t{\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(view1[i] !== view2[i])\r\n\t\t\treturn false;\r\n\t}\r\n\t\r\n\treturn true;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleReturnPointsJS\r\n/**\r\n * Pad input number with leade \"0\" if needed\r\n * @returns {string}\r\n * @param {number} inputNumber\r\n * @param {number} fullLength\r\n */\r\nexport function padNumber(inputNumber, fullLength)\r\n{\r\n\tconst str = inputNumber.toString(10);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tif(fullLength < str.length)\r\n\t\treturn \"\";\r\n\t\r\n\tconst dif = fullLength - str.length;\r\n\t\r\n\tconst padding = new Array(dif);\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < dif; i++)\r\n\t\tpadding[i] = \"0\";\r\n\t\r\n\tconst paddingString = padding.join(\"\");\r\n\t\r\n\treturn paddingString.concat(str);\r\n}\r\n//**************************************************************************************\r\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\r\n//**************************************************************************************\r\n// noinspection FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionTooLongJS, FunctionNamingConventionJS\r\n/**\r\n * Encode string into BASE64 (or \"base64url\")\r\n * @param {string} input\r\n * @param {boolean} useUrlTemplate If \"true\" then output would be encoded using \"base64url\"\r\n * @param {boolean} skipPadding Skip BASE-64 padding or not\r\n * @param {boolean} skipLeadingZeros Skip leading zeros in input data or not\r\n * @returns {string}\r\n */\r\nexport function toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false)\r\n{\r\n\tlet i = 0;\r\n\t\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tlet flag1 = 0;\r\n\t// noinspection LocalVariableNamingConventionJS\r\n\tlet flag2 = 0;\r\n\t\r\n\tlet output = \"\";\r\n\t\r\n\t// noinspection ConditionalExpressionJS\r\n\tconst template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n\t\r\n\tif(skipLeadingZeros)\r\n\t{\r\n\t\tlet nonZeroPosition = 0;\r\n\t\t\r\n\t\tfor(let i = 0; i < input.length; i++)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(input.charCodeAt(i) !== 0)\r\n\t\t\t{\r\n\t\t\t\tnonZeroPosition = i;\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection AssignmentToFunctionParameterJS\r\n\t\tinput = input.slice(nonZeroPosition);\r\n\t}\r\n\t\r\n\twhile(i < input.length)\r\n\t{\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr1 = input.charCodeAt(i++);\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(i >= input.length)\r\n\t\t\tflag1 = 1;\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr2 = input.charCodeAt(i++);\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(i >= input.length)\r\n\t\t\tflag2 = 1;\r\n\t\t// noinspection LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst chr3 = input.charCodeAt(i++);\r\n\t\t\r\n\t\t// noinspection LocalVariableNamingConventionJS\r\n\t\tconst enc1 = chr1 >> 2;\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst enc2 = ((chr1 & 0x03) << 4) | (chr2 >> 4);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tlet enc3 = ((chr2 & 0x0F) << 2) | (chr3 >> 6);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tlet enc4 = chr3 & 0x3F;\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\tif(flag1 === 1)\r\n\t\t{\r\n\t\t\t// noinspection NestedAssignmentJS, AssignmentResultUsedJS, MagicNumberJS\r\n\t\t\tenc3 = enc4 = 64;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(flag2 === 1)\r\n\t\t\t{\r\n\t\t\t\t// noinspection MagicNumberJS\r\n\t\t\t\tenc4 = 64;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS\r\n\t\tif(skipPadding)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\t\tif(enc3 === 64)\r\n\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}`;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\t\t\tif(enc4 === 64)\r\n\t\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\r\n\t\t\t\telse\r\n\t\t\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\toutput += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\r\n\t}\r\n\t\r\n\treturn output;\r\n}\r\n//**************************************************************************************\r\n// noinspection FunctionWithMoreThanThreeNegationsJS, FunctionWithMultipleLoopsJS, OverlyComplexFunctionJS, FunctionNamingConventionJS\r\n/**\r\n * Decode string from BASE64 (or \"base64url\")\r\n * @param {string} input\r\n * @param {boolean} [useUrlTemplate=false] If \"true\" then output would be encoded using \"base64url\"\r\n * @param {boolean} [cutTailZeros=false] If \"true\" then cut tailing zeroz from function result\r\n * @returns {string}\r\n */\r\nexport function fromBase64(input, useUrlTemplate = false, cutTailZeros = false)\r\n{\r\n\t// noinspection ConditionalExpressionJS\r\n\tconst template = (useUrlTemplate) ? base64UrlTemplate : base64Template;\r\n\t\r\n\t//region Aux functions\r\n\t// noinspection FunctionWithMultipleReturnPointsJS, NestedFunctionJS\r\n\tfunction indexof(toSearch)\r\n\t{\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, MagicNumberJS\r\n\t\tfor(let i = 0; i < 64; i++)\r\n\t\t{\r\n\t\t\t// noinspection NonBlockStatementBodyJS\r\n\t\t\tif(template.charAt(i) === toSearch)\r\n\t\t\t\treturn i;\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection MagicNumberJS\r\n\t\treturn 64;\r\n\t}\r\n\t\r\n\t// noinspection NestedFunctionJS\r\n\tfunction test(incoming)\r\n\t{\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, ConditionalExpressionJS, MagicNumberJS\r\n\t\treturn ((incoming === 64) ? 0x00 : incoming);\r\n\t}\r\n\t//endregion\r\n\t\r\n\tlet i = 0;\r\n\t\r\n\tlet output = \"\";\r\n\t\r\n\twhile(i < input.length)\r\n\t{\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc1 = indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc2 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc3 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t// noinspection NestedFunctionCallJS, LocalVariableNamingConventionJS, ConditionalExpressionJS, MagicNumberJS, IncrementDecrementResultUsedJS\r\n\t\tconst enc4 = (i >= input.length) ? 0x00 : indexof(input.charAt(i++));\r\n\t\t\r\n\t\t// noinspection LocalVariableNamingConventionJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr1 = (test(enc1) << 2) | (test(enc2) >> 4);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr2 = ((test(enc2) & 0x0F) << 4) | (test(enc3) >> 2);\r\n\t\t// noinspection LocalVariableNamingConventionJS, MagicNumberJS, NonShortCircuitBooleanExpressionJS\r\n\t\tconst chr3 = ((test(enc3) & 0x03) << 6) | test(enc4);\r\n\t\t\r\n\t\toutput += String.fromCharCode(chr1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\tif(enc3 !== 64)\r\n\t\t\toutput += String.fromCharCode(chr2);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS, NonBlockStatementBodyJS, MagicNumberJS\r\n\t\tif(enc4 !== 64)\r\n\t\t\toutput += String.fromCharCode(chr3);\r\n\t}\r\n\t\r\n\tif(cutTailZeros)\r\n\t{\r\n\t\tconst outputLength = output.length;\r\n\t\tlet nonZeroStart = (-1);\r\n\t\t\r\n\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\tfor(let i = (outputLength - 1); i >= 0; i--)\r\n\t\t{\r\n\t\t\t// noinspection ConstantOnRightSideOfComparisonJS\r\n\t\t\tif(output.charCodeAt(i) !== 0)\r\n\t\t\t{\r\n\t\t\t\tnonZeroStart = i;\r\n\t\t\t\t// noinspection BreakStatementJS\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// noinspection NonBlockStatementBodyJS, NegatedIfStatementJS\r\n\t\tif(nonZeroStart !== (-1))\r\n\t\t\toutput = output.slice(0, nonZeroStart + 1);\r\n\t\telse\r\n\t\t\toutput = \"\";\r\n\t}\r\n\t\r\n\treturn output;\r\n}\r\n//**************************************************************************************\r\nexport function arrayBufferToString(buffer)\r\n{\r\n\tlet resultString = \"\";\r\n\tconst view = new Uint8Array(buffer);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(const element of view)\r\n\t\tresultString += String.fromCharCode(element);\r\n\t\r\n\treturn resultString;\r\n}\r\n//**************************************************************************************\r\nexport function stringToArrayBuffer(str)\r\n{\r\n\tconst stringLength = str.length;\r\n\t\r\n\tconst resultBuffer = new ArrayBuffer(stringLength);\r\n\tconst resultView = new Uint8Array(resultBuffer);\r\n\t\r\n\t// noinspection NonBlockStatementBodyJS\r\n\tfor(let i = 0; i < stringLength; i++)\r\n\t\tresultView[i] = str.charCodeAt(i);\r\n\t\r\n\treturn resultBuffer;\r\n}\r\n//**************************************************************************************\r\nconst log2 = Math.log(2);\r\n//**************************************************************************************\r\n// noinspection FunctionNamingConventionJS\r\n/**\r\n * Get nearest to input length power of 2\r\n * @param {number} length Current length of existing array\r\n * @returns {number}\r\n */\r\nexport function nearestPowerOf2(length)\r\n{\r\n\tconst base = (Math.log(length) / log2);\r\n\t\r\n\tconst floor = Math.floor(base);\r\n\tconst round = Math.round(base);\r\n\t\r\n\t// noinspection ConditionalExpressionJS\r\n\treturn ((floor === round) ? floor : round);\r\n}\r\n//**************************************************************************************\r\n/**\r\n * Delete properties by name from specified object\r\n * @param {Object} object Object to delete properties from\r\n * @param {Array.<string>} propsArray Array of properties names\r\n */\r\nexport function clearProps(object, propsArray)\r\n{\r\n\tfor(const prop of propsArray)\r\n\t\tdelete object[prop];\r\n}\r\n//**************************************************************************************\r\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBER = fromBER;\nexports.compareSchema = compareSchema;\nexports.verifySchema = verifySchema;\nexports.fromJSON = fromJSON;\nexports.RawData = exports.Repeated = exports.Any = exports.Choice = exports.TIME = exports.Duration = exports.DateTime = exports.TimeOfDay = exports.DATE = exports.GeneralizedTime = exports.UTCTime = exports.CharacterString = exports.GeneralString = exports.VisibleString = exports.GraphicString = exports.IA5String = exports.VideotexString = exports.TeletexString = exports.PrintableString = exports.NumericString = exports.UniversalString = exports.BmpString = exports.RelativeObjectIdentifier = exports.Utf8String = exports.ObjectIdentifier = exports.Enumerated = exports.Integer = exports.BitString = exports.OctetString = exports.Null = exports.Set = exports.Sequence = exports.Boolean = exports.EndOfContent = exports.Constructed = exports.Primitive = exports.BaseBlock = exports.ValueBlock = exports.HexBlock = void 0;\n\nvar _pvutils = require(\"pvutils\");\n\n/* eslint-disable indent */\n\n/*\r\n * Copyright (c) 2016-2018, Peculiar Ventures\r\n * All rights reserved.\r\n *\r\n * Author 2016-2018, Yury Strozhevsky <www.strozhevsky.com>.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * 3. Neither the name of the copyright holder nor the names of its contributors\r\n *    may be used to endorse or promote products derived from this software without\r\n *    specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\r\n * OF SUCH DAMAGE.\r\n *\r\n */\n//**************************************************************************************\n//**************************************************************************************\n//region Declaration of global variables\n//**************************************************************************************\nconst powers2 = [new Uint8Array([1])];\nconst digitsString = \"0123456789\"; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration for \"LocalBaseBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @typedef LocalBaseBlock\r\n * @interface\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n */\n\nclass LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    /**\r\n     * @type {number} blockLength\r\n     */\n    this.blockLength = (0, _pvutils.getParametersValue)(parameters, \"blockLength\", 0);\n    /**\r\n     * @type {string} error\r\n     */\n\n    this.error = (0, _pvutils.getParametersValue)(parameters, \"error\", \"\");\n    /**\r\n     * @type {Array.<string>} warnings\r\n     */\n\n    this.warnings = (0, _pvutils.getParametersValue)(parameters, \"warnings\", []); //noinspection JSCheckFunctionSignatures\n\n    /**\r\n     * @type {ArrayBuffer} valueBeforeDecode\r\n     */\n\n    if (\"valueBeforeDecode\" in parameters) this.valueBeforeDecode = parameters.valueBeforeDecode.slice(0);else this.valueBeforeDecode = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"baseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    return {\n      blockName: this.constructor.blockName(),\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: (0, _pvutils.bufferToHexCodes)(this.valueBeforeDecode, 0, this.valueBeforeDecode.byteLength)\n    };\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Description for \"HexBlock\" class\n//**************************************************************************************\n\n/**\r\n * Class used as a base block for all remaining ASN.1 classes\r\n * @extends LocalBaseBlock\r\n * @typedef HexBlock\r\n * @property {number} blockLength\r\n * @property {string} error\r\n * @property {Array.<string>} warnings\r\n * @property {ArrayBuffer} valueBeforeDecode\r\n * @property {boolean} isHexOnly\r\n * @property {ArrayBuffer} valueHex\r\n */\n//noinspection JSUnusedLocalSymbols\n\n\nconst HexBlock = BaseClass => class LocalHexBlockMixin extends BaseClass {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"HexBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    /**\r\n     * @type {boolean}\r\n     */\n\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    /**\r\n     * @type {ArrayBuffer}\r\n     */\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"hexBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer to internal buffer\n\n\n    this.valueHex = inputBuffer.slice(inputOffset, inputOffset + inputLength); //endregion\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isHexOnly !== true) {\n      this.error = \"Flag \\\"isHexOnly\\\" is not set, abort\";\n      return new ArrayBuffer(0);\n    }\n\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength); //noinspection JSCheckFunctionSignatures\n\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n}; //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of identification block class\n//**************************************************************************************\n\n\nexports.HexBlock = HexBlock;\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [idBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"idBlock\" in parameters) {\n      //region Properties from hexBlock class\n      this.isHexOnly = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isHexOnly\", false);\n      this.valueHex = (0, _pvutils.getParametersValue)(parameters.idBlock, \"valueHex\", new ArrayBuffer(0)); //endregion\n\n      this.tagClass = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagClass\", -1);\n      this.tagNumber = (0, _pvutils.getParametersValue)(parameters.idBlock, \"tagNumber\", -1);\n      this.isConstructed = (0, _pvutils.getParametersValue)(parameters.idBlock, \"isConstructed\", false);\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"identificationBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let firstOctet = 0;\n    let retBuf;\n    let retView; //endregion\n\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0x00; // UNIVERSAL\n\n        break;\n\n      case 2:\n        firstOctet |= 0x40; // APPLICATION\n\n        break;\n\n      case 3:\n        firstOctet |= 0x80; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 4:\n        firstOctet |= 0xC0; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return new ArrayBuffer(0);\n    }\n\n    if (this.isConstructed) firstOctet |= 0x20;\n\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      retBuf = new ArrayBuffer(1);\n      retView = new Uint8Array(retBuf);\n\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 0x1F;\n        firstOctet |= number;\n        retView[0] = firstOctet;\n      }\n\n      return retBuf;\n    }\n\n    if (this.isHexOnly === false) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      retBuf = new ArrayBuffer(size + 1);\n      retView = new Uint8Array(retBuf);\n      retView[0] = firstOctet | 0x1F;\n\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++) retView[i + 1] = encodedView[i] | 0x80;\n\n        retView[size] = encodedView[size - 1];\n      }\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    retView = new Uint8Array(retBuf);\n    retView[0] = firstOctet | 0x1F;\n\n    if (sizeOnly === false) {\n      const curView = new Uint8Array(this.valueHex);\n\n      for (let i = 0; i < curView.length - 1; i++) retView[i + 1] = curView[i] | 0x80;\n\n      retView[this.valueHex.byteLength] = curView[curView.length - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    } //endregion\n    //region Find tag class\n\n\n    const tagClassMask = intBuffer[0] & 0xC0;\n\n    switch (tagClassMask) {\n      case 0x00:\n        this.tagClass = 1; // UNIVERSAL\n\n        break;\n\n      case 0x40:\n        this.tagClass = 2; // APPLICATION\n\n        break;\n\n      case 0x80:\n        this.tagClass = 3; // CONTEXT-SPECIFIC\n\n        break;\n\n      case 0xC0:\n        this.tagClass = 4; // PRIVATE\n\n        break;\n\n      default:\n        this.error = \"Unknown tag class\";\n        return -1;\n    } //endregion\n    //region Find it's constructed or not\n\n\n    this.isConstructed = (intBuffer[0] & 0x20) === 0x20; //endregion\n    //region Find tag number\n\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 0x1F; //region Simple case (tag number < 31)\n\n    if (tagNumberMask !== 0x1F) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } //endregion\n    //region Tag number bigger or equal to 31\n    else {\n        let count = 1;\n        this.valueHex = new ArrayBuffer(255);\n        let tagNumberBufferMaxLength = 255;\n        let intTagNumberBuffer = new Uint8Array(this.valueHex); //noinspection JSBitwiseOperatorUsage\n\n        while (intBuffer[count] & 0x80) {\n          intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\n          count++;\n\n          if (count >= intBuffer.length) {\n            this.error = \"End of input reached before message was fully decoded\";\n            return -1;\n          } //region In case if tag number length is greater than 255 bytes (rare but possible case)\n\n\n          if (count === tagNumberBufferMaxLength) {\n            tagNumberBufferMaxLength += 255;\n            const tempBuffer = new ArrayBuffer(tagNumberBufferMaxLength);\n            const tempBufferView = new Uint8Array(tempBuffer);\n\n            for (let i = 0; i < intTagNumberBuffer.length; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n            this.valueHex = new ArrayBuffer(tagNumberBufferMaxLength);\n            intTagNumberBuffer = new Uint8Array(this.valueHex);\n          } //endregion\n\n        }\n\n        this.blockLength = count + 1;\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F; // Write last byte to buffer\n        //region Cut buffer\n\n        const tempBuffer = new ArrayBuffer(count);\n        const tempBufferView = new Uint8Array(tempBuffer);\n\n        for (let i = 0; i < count; i++) tempBufferView[i] = intTagNumberBuffer[i];\n\n        this.valueHex = new ArrayBuffer(count);\n        intTagNumberBuffer = new Uint8Array(this.valueHex);\n        intTagNumberBuffer.set(tempBufferView); //endregion\n        //region Try to convert long tag number to short form\n\n        if (this.blockLength <= 9) this.tagNumber = (0, _pvutils.utilFromBase)(intTagNumberBuffer, 7);else {\n          this.isHexOnly = true;\n          this.warnings.push(\"Tag too long, represented as hex-coded\");\n        } //endregion\n      } //endregion\n    //endregion\n    //region Check if constructed encoding was using for primitive type\n\n\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1: // Boolean\n\n        case 2: // REAL\n\n        case 5: // Null\n\n        case 6: // OBJECT IDENTIFIER\n\n        case 9: // REAL\n\n        case 13: // RELATIVE OBJECT IDENTIFIER\n\n        case 14: // Time\n\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = \"Constructed encoding used for primitive type\";\n          return -1;\n\n        default:\n      }\n    } //endregion\n\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName: string,\r\n   *  tagClass: number,\r\n   *  tagNumber: number,\r\n   *  isConstructed: boolean,\r\n   *  isHexOnly: boolean,\r\n   *  valueHex: ArrayBuffer,\r\n   *  blockLength: number,\r\n   *  error: string, warnings: Array.<string>,\r\n   *  valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.tagClass = this.tagClass;\n    object.tagNumber = this.tagNumber;\n    object.isConstructed = this.isConstructed;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of length block class\n//**************************************************************************************\n\n\nclass LocalLengthBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalLengthBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [lenBlock]\r\n   */\n  constructor(parameters = {}) {\n    super();\n\n    if (\"lenBlock\" in parameters) {\n      this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"isIndefiniteForm\", false);\n      this.longFormUsed = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"longFormUsed\", false);\n      this.length = (0, _pvutils.getParametersValue)(parameters.lenBlock, \"length\", 0);\n    } else {\n      this.isIndefiniteForm = false;\n      this.longFormUsed = false;\n      this.length = 0;\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"lengthBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.error = \"Zero buffer length\";\n      return -1;\n    }\n\n    if (intBuffer[0] === 0xFF) {\n      this.error = \"Length block 0xFF is reserved by standard\";\n      return -1;\n    } //endregion\n    //region Check for length form type\n\n\n    this.isIndefiniteForm = intBuffer[0] === 0x80; //endregion\n    //region Stop working in case of indefinite length form\n\n    if (this.isIndefiniteForm === true) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Check is long form of length encoding using\n\n\n    this.longFormUsed = !!(intBuffer[0] & 0x80); //endregion\n    //region Stop working in case of short form of length value\n\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    } //endregion\n    //region Calculate length value in case of long form\n\n\n    const count = intBuffer[0] & 0x7F;\n\n    if (count > 8) // Too big length value\n      {\n        this.error = \"Too big integer\";\n        return -1;\n      }\n\n    if (count + 1 > intBuffer.length) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    const lengthBufferView = new Uint8Array(count);\n\n    for (let i = 0; i < count; i++) lengthBufferView[i] = intBuffer[i + 1];\n\n    if (lengthBufferView[count - 1] === 0x00) this.warnings.push(\"Needlessly long encoded length\");\n    this.length = (0, _pvutils.utilFromBase)(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127) this.warnings.push(\"Unneccesary usage of long length form\");\n    this.blockLength = count + 1; //endregion\n\n    return inputOffset + this.blockLength; // Return current offset in input buffer\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.length > 127) this.longFormUsed = true;\n\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 0x80;\n      }\n\n      return retBuf;\n    }\n\n    if (this.longFormUsed === true) {\n      const encodedBuf = (0, _pvutils.utilToBase)(this.length, 8);\n\n      if (encodedBuf.byteLength > 127) {\n        this.error = \"Too big length\";\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly === true) return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 0x80;\n\n      for (let i = 0; i < encodedBuf.byteLength; i++) retView[i + 1] = encodedView[i];\n\n      return retBuf;\n    }\n\n    retBuf = new ArrayBuffer(1);\n\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.blockName = this.constructor.blockName();\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.longFormUsed = this.longFormUsed;\n    object.length = this.length;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of value block class\n//**************************************************************************************\n\n\nclass ValueBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"valueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Throw an exception for a function which needs to be specified in extended classes\n    throw TypeError(\"User need to make a specific function in a class which extends \\\"ValueBlock\\\"\"); //endregion\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic ASN.1 block class\n//**************************************************************************************\n\n\nexports.ValueBlock = ValueBlock;\n\nclass BaseBlock extends LocalBaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BaseBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Object} [primitiveSchema]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   * @param valueBlockType Type of value block\r\n   */\n  constructor(parameters = {}, valueBlockType = ValueBlock) {\n    super(parameters);\n    if (\"name\" in parameters) this.name = parameters.name;\n    if (\"optional\" in parameters) this.optional = parameters.optional;\n    if (\"primitiveSchema\" in parameters) this.primitiveSchema = parameters.primitiveSchema;\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = new valueBlockType(parameters);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BaseBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf;\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    const valueBlockSizeBuf = this.valueBlock.toBER(true);\n    this.lenBlock.length = valueBlockSizeBuf.byteLength;\n    const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n    retBuf = (0, _pvutils.utilConcatBuf)(idBlockBuf, lenBlockBuf);\n    let valueBlockBuf;\n    if (sizeOnly === false) valueBlockBuf = this.valueBlock.toBER(sizeOnly);else valueBlockBuf = new ArrayBuffer(this.lenBlock.length);\n    retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBlockBuf);\n\n    if (this.lenBlock.isIndefiniteForm === true) {\n      const indefBuf = new ArrayBuffer(2);\n\n      if (sizeOnly === false) {\n        const indefView = new Uint8Array(indefBuf);\n        indefView[0] = 0x00;\n        indefView[1] = 0x00;\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, indefBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.idBlock = this.idBlock.toJSON();\n    object.lenBlock = this.lenBlock.toJSON();\n    object.valueBlock = this.valueBlock.toJSON();\n    if (\"name\" in this) object.name = this.name;\n    if (\"optional\" in this) object.optional = this.optional;\n    if (\"primitiveSchema\" in this) object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all PRIMITIVE types\n//**************************************************************************************\n\n\nexports.BaseBlock = BaseBlock;\n\nclass LocalPrimitiveValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalPrimitiveValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueBeforeDecode]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters); //region Variables from \"hexBlock\" class\n\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else this.valueHex = new ArrayBuffer(0);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", true); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Copy input buffer into internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const valueHexView = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) valueHexView[i] = intBuffer[i]; //endregion\n\n\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrimitiveValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    object.isHexOnly = this.isHexOnly;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Primitive extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Primitive\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PRIMITIVE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of basic block for all CONSTRUCTED types\n//**************************************************************************************\n\n\nexports.Primitive = Primitive;\n\nclass LocalConstructedValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalConstructedValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.isIndefiniteForm = (0, _pvutils.getParametersValue)(parameters, \"isIndefiniteForm\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Store initial offset and length\n    const initialOffset = inputOffset;\n    const initialLength = inputLength; //endregion\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n    //region Initial checks\n\n    if (intBuffer.length === 0) {\n      this.warnings.push(\"Zero buffer length\");\n      return inputOffset;\n    } //endregion\n    //region Aux function\n\n\n    function checkLen(indefiniteLength, length) {\n      if (indefiniteLength === true) return 1;\n      return length;\n    } //endregion\n\n\n    let currentOffset = inputOffset;\n\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = LocalFromBER(inputBuffer, currentOffset, inputLength);\n\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm === true && returnObject.result.constructor.blockName() === EndOfContent.blockName()) break;\n    }\n\n    if (this.isIndefiniteForm === true) {\n      if (this.value[this.value.length - 1].constructor.blockName() === EndOfContent.blockName()) this.value.pop();else this.warnings.push(\"No EndOfContent block encoded\");\n    } //region Copy \"inputBuffer\" to \"valueBeforeDecode\"\n\n\n    this.valueBeforeDecode = inputBuffer.slice(initialOffset, initialOffset + initialLength); //endregion\n\n    return currentOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ConstructedValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isIndefiniteForm = this.isIndefiniteForm;\n    object.value = [];\n\n    for (let i = 0; i < this.value.length; i++) object.value.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Constructed extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Constructed\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CONSTRUCTED\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 EndOfContent type class\n//**************************************************************************************\n\n\nexports.Constructed = Constructed;\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalEndOfContentValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols,JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number}\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region There is no \"value block\" for EndOfContent type and we need to return the same offset\n    return inputOffset; //endregion\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return new ArrayBuffer(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContentValueBlock\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass EndOfContent extends BaseBlock {\n  //**********************************************************************************\n  constructor(paramaters = {}) {\n    super(paramaters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 0; // EndOfContent\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"EndOfContent\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Boolean type class\n//**************************************************************************************\n\n\nexports.EndOfContent = EndOfContent;\n\nclass LocalBooleanValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBooleanValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", false);\n    this.isHexOnly = (0, _pvutils.getParametersValue)(parameters, \"isHexOnly\", false);\n    if (\"valueHex\" in parameters) this.valueHex = parameters.valueHex.slice(0);else {\n      this.valueHex = new ArrayBuffer(1);\n\n      if (this.value === true) {\n        const view = new Uint8Array(this.valueHex);\n        view[0] = 0xFF;\n      }\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n    //region Getting Uint8Array from ArrayBuffer\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n\n    if (inputLength > 1) this.warnings.push(\"Boolean value encoded in more then 1 octet\");\n    this.isHexOnly = true; //region Copy input buffer to internal array\n\n    this.valueHex = new ArrayBuffer(intBuffer.length);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < intBuffer.length; i++) view[i] = intBuffer[i]; //endregion\n\n\n    if (_pvutils.utilDecodeTC.call(this) !== 0) this.value = true;else this.value = false;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BooleanValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Boolean extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Boolean\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 1; // Boolean\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Boolean\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Sequence and Set type classes\n//**************************************************************************************\n\n\nexports.Boolean = Boolean;\n\nclass Sequence extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Sequence\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 16; // Sequence\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Sequence\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.Sequence = Sequence;\n\nclass Set extends Constructed {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Set\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 17; // Set\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Set\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Null type class\n//**************************************************************************************\n\n\nexports.Set = Set;\n\nclass Null extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Null\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBaseBlock); // We will not have a call to \"Null value block\" because of specified \"fromBER\" and \"toBER\" functions\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 5; // Null\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Null\";\n  } //**********************************************************************************\n  //noinspection JSUnusedLocalSymbols\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0) this.warnings.push(\"Non-zero length of value block for Null type\");\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n      return -1;\n    }\n\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    const retBuf = new ArrayBuffer(2);\n    if (sizeOnly === true) return retBuf;\n    const retView = new Uint8Array(retBuf);\n    retView[0] = 0x05;\n    retView[1] = 0x00;\n    return retBuf;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 OctetString type class\n//**************************************************************************************\n\n\nexports.Null = Null;\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalOctetStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n\n    if (this.isConstructed === true) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== OctetString.blockName()) {\n          this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    let retBuf = new ArrayBuffer(this.valueHex.byteLength);\n    if (sizeOnly === true) return retBuf;\n    if (this.valueHex.byteLength === 0) return retBuf;\n    retBuf = this.valueHex.slice(0);\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetStringValueBlock\";\n  } //**********************************************************************************\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass OctetString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"OctetString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 4; // OctetString\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm; //region Ability to encode empty OCTET STRING\n\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    } //endregion\n\n\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"OctetString\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Checking that two OCTETSTRINGs are equal\r\n   * @param {OctetString} octetString\r\n   */\n\n\n  isEqual(octetString) {\n    //region Check input type\n    if (octetString instanceof OctetString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(octetString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 BitString type class\n//**************************************************************************************\n\n\nexports.OctetString = OctetString;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBitStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.unusedBits = (0, _pvutils.getParametersValue)(parameters, \"unusedBits\", 0);\n    this.isConstructed = (0, _pvutils.getParametersValue)(parameters, \"isConstructed\", false);\n    this.blockLength = this.valueHex.byteLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to decode zero-length BitString value\n    if (inputLength === 0) return inputOffset; //endregion\n\n    let resultOffset = -1; //region If the BISTRING supposed to be a constructed value\n\n    if (this.isConstructed === true) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1) return resultOffset;\n\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.blockName();\n\n        if (currentBlockName === EndOfContent.blockName()) {\n          if (this.isIndefiniteForm === true) break;else {\n            this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\n            return -1;\n          }\n        }\n\n        if (currentBlockName !== BitString.blockName()) {\n          this.error = \"BIT STRING may consists of BIT STRINGs only\";\n          return -1;\n        }\n\n        if (this.unusedBits > 0 && this.value[i].valueBlock.unusedBits > 0) {\n          this.error = \"Usign of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\n          return -1;\n        }\n\n        this.unusedBits = this.value[i].valueBlock.unusedBits;\n\n        if (this.unusedBits > 7) {\n          this.error = \"Unused bits for BitString must be in range 0-7\";\n          return -1;\n        }\n      }\n\n      return resultOffset;\n    } //endregion\n    //region If the BitString supposed to be a primitive value\n    //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.unusedBits = intBuffer[0];\n\n    if (this.unusedBits > 7) {\n      this.error = \"Unused bits for BitString must be in range 0-7\";\n      return -1;\n    } //region Copy input buffer to internal buffer\n\n\n    this.valueHex = new ArrayBuffer(intBuffer.length - 1);\n    const view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength - 1; i++) view[i] = intBuffer[i + 1]; //endregion\n\n\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength; //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    if (this.isConstructed === true) return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly);\n    if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength + 1);\n    if (this.valueHex.byteLength === 0) return new ArrayBuffer(0);\n    const curView = new Uint8Array(this.valueHex);\n    const retBuf = new ArrayBuffer(this.valueHex.byteLength + 1);\n    const retView = new Uint8Array(retBuf);\n    retView[0] = this.unusedBits;\n\n    for (let i = 0; i < this.valueHex.byteLength; i++) retView[i + 1] = curView[i];\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitStringValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {{blockName, blockLength, error, warnings, valueBeforeDecode}|{blockName: string, blockLength: number, error: string, warnings: Array.<string>, valueBeforeDecode: string}}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.unusedBits = this.unusedBits;\n    object.isConstructed = this.isConstructed;\n    object.isHexOnly = this.isHexOnly;\n    object.valueHex = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass BitString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BitString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 3; // BitString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BitString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    //region Ability to encode empty BitString\n    if (inputLength === 0) return inputOffset; //endregion\n\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  } //**********************************************************************************\n\n  /**\r\n   * Checking that two BITSTRINGs are equal\r\n   * @param {BitString} bitString\r\n   */\n\n\n  isEqual(bitString) {\n    //region Check input type\n    if (bitString instanceof BitString === false) return false; //endregion\n    //region Compare two JSON strings\n\n    if (JSON.stringify(this) !== JSON.stringify(bitString)) return false; //endregion\n\n    return true;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Integer type class\n//**************************************************************************************\n\n/**\r\n * @extends ValueBlock\r\n */\n\n\nexports.BitString = BitString;\n\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalIntegerValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    if (\"value\" in parameters) this.valueDec = parameters.value;\n  } //**********************************************************************************\n\n  /**\r\n   * Setter for \"valueHex\"\r\n   * @param {ArrayBuffer} _value\r\n   */\n\n\n  set valueHex(_value) {\n    this._valueHex = _value.slice(0);\n\n    if (_value.byteLength >= 4) {\n      this.warnings.push(\"Too big Integer for decoding, hex only\");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (_value.byteLength > 0) this._valueDec = _pvutils.utilDecodeTC.call(this);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueHex\"\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  get valueHex() {\n    return this._valueHex;\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @param {number} _value\r\n   */\n\n\n  set valueDec(_value) {\n    this._valueDec = _value;\n    this.isHexOnly = false;\n    this._valueHex = (0, _pvutils.utilEncodeTC)(_value);\n  } //**********************************************************************************\n\n  /**\r\n   * Getter for \"valueDec\"\r\n   * @returns {number}\r\n   */\n\n\n  get valueDec() {\n    return this._valueDec;\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from DER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 DER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 DER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @param {number} [expectedLength=0] Expected length of converted \"valueHex\" buffer\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1) return offset;\n    const view = new Uint8Array(this._valueHex);\n\n    if (view[0] === 0x00 && (view[1] & 0x80) !== 0) {\n      const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n      const updatedView = new Uint8Array(updatedValueHex);\n      updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n      this._valueHex = updatedValueHex.slice(0);\n    } else {\n      if (expectedLength !== 0) {\n        if (this._valueHex.byteLength < expectedLength) {\n          if (expectedLength - this._valueHex.byteLength > 1) expectedLength = this._valueHex.byteLength + 1;\n          const updatedValueHex = new ArrayBuffer(expectedLength);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(view, expectedLength - this._valueHex.byteLength);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n      }\n    }\n\n    return offset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (DER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toDER(sizeOnly = false) {\n    const view = new Uint8Array(this._valueHex);\n\n    switch (true) {\n      case (view[0] & 0x80) !== 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength + 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView[0] = 0x00;\n          updatedView.set(view, 1);\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      case view[0] === 0x00 && (view[1] & 0x80) === 0:\n        {\n          const updatedValueHex = new ArrayBuffer(this._valueHex.byteLength - 1);\n          const updatedView = new Uint8Array(updatedValueHex);\n          updatedView.set(new Uint8Array(this._valueHex, 1, this._valueHex.byteLength - 1));\n          this._valueHex = updatedValueHex.slice(0);\n        }\n        break;\n\n      default:\n    }\n\n    return this.toBER(sizeOnly);\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) return resultOffset;\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //noinspection JSCheckFunctionSignatures\n    return this.valueHex.slice(0);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IntegerValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current value to decimal string representation\r\n   */\n\n\n  toString() {\n    //region Aux functions\n    function viewAdd(first, second) {\n      //region Initial variables\n      const c = new Uint8Array([0]);\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value = 0;\n      const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n      let counter = 0; //endregion\n\n      for (let i = max; i >= 0; i--, counter++) {\n        switch (true) {\n          case counter < secondViewCopy.length:\n            value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n            break;\n\n          default:\n            value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n        }\n\n        c[0] = value / 10;\n\n        switch (true) {\n          case counter >= firstViewCopy.length:\n            firstViewCopy = (0, _pvutils.utilConcatView)(new Uint8Array([value % 10]), firstViewCopy);\n            break;\n\n          default:\n            firstViewCopy[firstViewCopyLength - counter] = value % 10;\n        }\n      }\n\n      if (c[0] > 0) firstViewCopy = (0, _pvutils.utilConcatView)(c, firstViewCopy);\n      return firstViewCopy.slice(0);\n    }\n\n    function power2(n) {\n      if (n >= powers2.length) {\n        for (let p = powers2.length; p <= n; p++) {\n          const c = new Uint8Array([0]);\n          let digits = powers2[p - 1].slice(0);\n\n          for (let i = digits.length - 1; i >= 0; i--) {\n            const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n            c[0] = newValue[0] / 10;\n            digits[i] = newValue[0] % 10;\n          }\n\n          if (c[0] > 0) digits = (0, _pvutils.utilConcatView)(c, digits);\n          powers2.push(digits);\n        }\n      }\n\n      return powers2[n];\n    }\n\n    function viewSub(first, second) {\n      //region Initial variables\n      let b = 0;\n      let firstView = new Uint8Array(first);\n      let secondView = new Uint8Array(second);\n      let firstViewCopy = firstView.slice(0);\n      const firstViewCopyLength = firstViewCopy.length - 1;\n      let secondViewCopy = secondView.slice(0);\n      const secondViewCopyLength = secondViewCopy.length - 1;\n      let value;\n      let counter = 0; //endregion\n\n      for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n\n        switch (true) {\n          case value < 0:\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n            break;\n\n          default:\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n        }\n      }\n\n      if (b > 0) {\n        for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n          value = firstViewCopy[firstViewCopyLength - counter] - b;\n\n          if (value < 0) {\n            b = 1;\n            firstViewCopy[firstViewCopyLength - counter] = value + 10;\n          } else {\n            b = 0;\n            firstViewCopy[firstViewCopyLength - counter] = value;\n            break;\n          }\n        }\n      }\n\n      return firstViewCopy.slice();\n    } //endregion\n    //region Initial variables\n\n\n    const firstBit = this._valueHex.byteLength * 8 - 1;\n    let digits = new Uint8Array(this._valueHex.byteLength * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = new Uint8Array(this._valueHex);\n    let result = \"\";\n    let flag = false; //endregion\n    //region Calculate number\n\n    for (let byteNumber = this._valueHex.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = \"-\";\n              break;\n\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    } //endregion\n    //region Print number\n\n\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i]) flag = true;\n      if (flag) result += digitsString.charAt(digits[i]);\n    }\n\n    if (flag === false) result += digitsString.charAt(0); //endregion\n\n    return result;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass Integer extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Integer\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 2; // Integer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Integer\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Compare two Integer object, or Integer and ArrayBuffer objects\r\n   * @param {!Integer|ArrayBuffer} otherValue\r\n   * @returns {boolean}\r\n   */\n\n\n  isEqual(otherValue) {\n    if (otherValue instanceof Integer) {\n      if (this.valueBlock.isHexOnly && otherValue.valueBlock.isHexOnly) // Compare two ArrayBuffers\n        return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue.valueBlock.valueHex);\n      if (this.valueBlock.isHexOnly === otherValue.valueBlock.isHexOnly) return this.valueBlock.valueDec === otherValue.valueBlock.valueDec;\n      return false;\n    }\n\n    if (otherValue instanceof ArrayBuffer) return (0, _pvutils.isEqualBuffer)(this.valueBlock.valueHex, otherValue);\n    return false;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from BER into DER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertToDER() {\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.toDER();\n    return integer;\n  } //**********************************************************************************\n\n  /**\r\n   * Convert current Integer value from DER to BER format\r\n   * @returns {Integer}\r\n   */\n\n\n  convertFromDER() {\n    const expectedLength = this.valueBlock.valueHex.byteLength % 2 ? this.valueBlock.valueHex.byteLength + 1 : this.valueBlock.valueHex.byteLength;\n    const integer = new Integer({\n      valueHex: this.valueBlock.valueHex\n    });\n    integer.valueBlock.fromDER(integer.valueBlock.valueHex, 0, integer.valueBlock.valueHex.byteLength, expectedLength);\n    return integer;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 Enumerated type class\n//**************************************************************************************\n\n\nexports.Integer = Integer;\n\nclass Enumerated extends Integer {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Enumerated\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 10; // Enumerated\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Enumerated\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of ASN.1 ObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Enumerated = Enumerated;\n\nclass LocalSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   * @property {boolean} [isFirstSid]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n    this.isFirstSid = (0, _pvutils.getParametersValue)(parameters, \"isFirstSid\", false);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"sidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39) result = \"0.\";else {\n          if (this.valueDec <= 79) {\n            result = \"1.\";\n            sidValue -= 40;\n          } else {\n            result = \"2.\";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    object.isFirstSid = this.isFirstSid;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      if (this.value.length === 0) sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n    let flag = false;\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n\n          case 1:\n            plus = 40;\n            break;\n\n          case 2:\n            plus = 80;\n            break;\n\n          default:\n            this.value = []; // clear SID array\n\n            return false;\n          // ???\n        }\n\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID)) return true;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n        sidBlock.valueDec = parseInt(sid, 10);\n        if (isNaN(sidBlock.valueDec)) return true;\n\n        if (this.value.length === 0) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid) result = `2.{${sidStr} - 80}`;else result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass ObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"ObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 6; // OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"ObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all string's classes\n//**************************************************************************************\n\n\nexports.ObjectIdentifier = ObjectIdentifier;\n\nclass LocalUtf8StringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Constructor for \"LocalUtf8StringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\"; // String representation of decoded ArrayBuffer\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8StringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass Utf8String extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Utf8String\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUtf8StringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 12; // Utf8String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Utf8String\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n\n    try {\n      //noinspection JSDeprecatedSymbols\n      this.valueBlock.value = decodeURIComponent(escape(this.valueBlock.value));\n    } catch (ex) {\n      this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\n    }\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //noinspection JSDeprecatedSymbols\n    const str = unescape(encodeURIComponent(inputString));\n    const strLen = str.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = str.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//region Declaration of ASN.1 RelativeObjectIdentifier type class\n//**************************************************************************************\n\n\nexports.Utf8String = Utf8String;\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeSidValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {number} [valueDec]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.valueDec = (0, _pvutils.getParametersValue)(parameters, \"valueDec\", -1);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"relativeSidBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0) return inputOffset; //region Basic check for parameters\n    //noinspection JSCheckFunctionSignatures\n\n    if ((0, _pvutils.checkBufferParams)(this, inputBuffer, inputOffset, inputLength) === false) return -1; //endregion\n\n    const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength);\n    this.valueHex = new ArrayBuffer(inputLength);\n    let view = new Uint8Array(this.valueHex);\n\n    for (let i = 0; i < inputLength; i++) {\n      view[i] = intBuffer[i] & 0x7F;\n      this.blockLength++;\n      if ((intBuffer[i] & 0x80) === 0x00) break;\n    } //region Ajust size of valueHex buffer\n\n\n    const tempValueHex = new ArrayBuffer(this.blockLength);\n    const tempView = new Uint8Array(tempValueHex);\n\n    for (let i = 0; i < this.blockLength; i++) tempView[i] = view[i]; //noinspection JSCheckFunctionSignatures\n\n\n    this.valueHex = tempValueHex.slice(0);\n    view = new Uint8Array(this.valueHex); //endregion\n\n    if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\n      this.error = \"End of input reached before message was fully decoded\";\n      return -1;\n    }\n\n    if (view[0] === 0x00) this.warnings.push(\"Needlessly long format of SID encoding\");\n    if (this.blockLength <= 8) this.valueDec = (0, _pvutils.utilFromBase)(view, 7);else {\n      this.isHexOnly = true;\n      this.warnings.push(\"Too big SID for decoding, hex only\");\n    }\n    return inputOffset + this.blockLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    //region Initial variables\n    let retBuf;\n    let retView; //endregion\n\n    if (this.isHexOnly) {\n      if (sizeOnly === true) return new ArrayBuffer(this.valueHex.byteLength);\n      const curView = new Uint8Array(this.valueHex);\n      retBuf = new ArrayBuffer(this.blockLength);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < this.blockLength - 1; i++) retView[i] = curView[i] | 0x80;\n\n      retView[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retBuf;\n    }\n\n    const encodedBuf = (0, _pvutils.utilToBase)(this.valueDec, 7);\n\n    if (encodedBuf.byteLength === 0) {\n      this.error = \"Error during encoding SID value\";\n      return new ArrayBuffer(0);\n    }\n\n    retBuf = new ArrayBuffer(encodedBuf.byteLength);\n\n    if (sizeOnly === false) {\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n\n      for (let i = 0; i < encodedBuf.byteLength - 1; i++) retView[i] = encodedView[i] | 0x80;\n\n      retView[encodedBuf.byteLength - 1] = encodedView[encodedBuf.byteLength - 1];\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create string representation of current SID block\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    if (this.isHexOnly === true) result = (0, _pvutils.bufferToHexCodes)(this.valueHex, 0, this.valueHex.byteLength);else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.valueDec = this.valueDec;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalRelativeObjectIdentifierValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.fromString((0, _pvutils.getParametersValue)(parameters, \"value\", \"\"));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    let retBuf = new ArrayBuffer(0);\n\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return new ArrayBuffer(0);\n      }\n\n      retBuf = (0, _pvutils.utilConcatBuf)(retBuf, valueBuf);\n    }\n\n    return retBuf;\n  } //**********************************************************************************\n\n  /**\r\n   * Create \"LocalRelativeObjectIdentifierValueBlock\" class from string\r\n   * @param {string} string Input string to convert from\r\n   * @returns {boolean}\r\n   */\n\n\n  fromString(string) {\n    this.value = []; // Clear existing SID values\n\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = \"\";\n\n    do {\n      pos2 = string.indexOf(\".\", pos1);\n      if (pos2 === -1) sid = string.substr(pos1);else sid = string.substr(pos1, pos2 - pos1);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec)) return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n\n    return true;\n  } //**********************************************************************************\n\n  /**\r\n   * Converts \"LocalRelativeObjectIdentifierValueBlock\" class to string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    let result = \"\";\n    let isHexOnly = false;\n\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0) result = `${result}.`;\n\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else result += sidStr;\n    }\n\n    return result;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifierValueBlock\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.toString();\n    object.sidArray = [];\n\n    for (let i = 0; i < this.value.length; i++) object.sidArray.push(this.value[i].toJSON());\n\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass RelativeObjectIdentifier extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"RelativeObjectIdentifier\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {ArrayBuffer} [valueHex]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 13; // RELATIVE OBJECT IDENTIFIER\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"RelativeObjectIdentifier\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n\n/**\r\n * @extends LocalBaseBlock\r\n * @extends HexBlock\r\n */\n\n\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\n\nclass LocalBmpStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalBmpStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass BmpString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"BmpString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalBmpStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 30; // BmpString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"BmpString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 2) {\n      const temp = valueView[i];\n      valueView[i] = valueView[i + 1];\n      valueView[i + 1] = temp;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint16Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 2);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 2) continue;\n      const dif = 2 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 2 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.BmpString = BmpString;\n\nclass LocalUniversalStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalUniversalStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = \"\";\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass UniversalString extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UniversalString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalUniversalStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 28; // UniversalString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UniversalString\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    //noinspection JSCheckFunctionSignatures\n    const copyBuffer = inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0x00;\n      valueView[i + 3] = 0x00;\n    }\n\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLength = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLength * 4);\n    const valueHexView = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = (0, _pvutils.utilToBase)(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4) continue;\n      const dif = 4 - codeView.length;\n\n      for (let j = codeView.length - 1; j >= 0; j--) valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n\nexports.UniversalString = UniversalString;\n\nclass LocalSimpleStringValueBlock extends HexBlock(LocalBaseBlock) {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringValueBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.value = \"\";\n    this.isHexOnly = true;\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SimpleStringValueBlock\";\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.value = this.value;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends BaseBlock\r\n */\n\n\nclass LocalSimpleStringBlock extends BaseBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"LocalSimpleStringBlock\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters, LocalSimpleStringValueBlock);\n    if (\"value\" in parameters) this.fromString(parameters.value);\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"SIMPLESTRING\";\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint8Array(inputBuffer));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    const strLen = inputString.length;\n    this.valueBlock.valueHex = new ArrayBuffer(strLen);\n    const view = new Uint8Array(this.valueBlock.valueHex);\n\n    for (let i = 0; i < strLen; i++) view[i] = inputString.charCodeAt(i);\n\n    this.valueBlock.value = inputString;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nclass NumericString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"NumericString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 18; // NumericString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"NumericString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.NumericString = NumericString;\n\nclass PrintableString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"PrintableString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 19; // PrintableString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"PrintableString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.PrintableString = PrintableString;\n\nclass TeletexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TeletexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 20; // TeletexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TeletexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.TeletexString = TeletexString;\n\nclass VideotexString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VideotexString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 21; // VideotexString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VideotexString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VideotexString = VideotexString;\n\nclass IA5String extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"IA5String\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 22; // IA5String\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"IA5String\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.IA5String = IA5String;\n\nclass GraphicString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GraphicString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 25; // GraphicString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GraphicString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GraphicString = GraphicString;\n\nclass VisibleString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"VisibleString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 26; // VisibleString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"VisibleString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.VisibleString = VisibleString;\n\nclass GeneralString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 27; // GeneralString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends LocalSimpleStringBlock\r\n */\n\n\nexports.GeneralString = GeneralString;\n\nclass CharacterString extends LocalSimpleStringBlock {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"CharacterString\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 29; // CharacterString\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"CharacterString\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of all date and time classes\n//**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.CharacterString = CharacterString;\n\nclass UTCTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"UTCTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 23; // UTCTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Parse input string\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n\n    if (parserArray === null) {\n      this.error = \"Wrong input string for convertion\";\n      return;\n    } //endregion\n    //region Store parsed values\n\n\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50) this.year = 1900 + year;else this.year = 2000 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10); //endregion\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = new Array(7);\n    outputArray[0] = (0, _pvutils.padNumber)(this.year < 2000 ? this.year - 1900 : this.year - 2000, 2);\n    outputArray[1] = (0, _pvutils.padNumber)(this.month, 2);\n    outputArray[2] = (0, _pvutils.padNumber)(this.day, 2);\n    outputArray[3] = (0, _pvutils.padNumber)(this.hour, 2);\n    outputArray[4] = (0, _pvutils.padNumber)(this.minute, 2);\n    outputArray[5] = (0, _pvutils.padNumber)(this.second, 2);\n    outputArray[6] = \"Z\";\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"UTCTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends VisibleString\r\n */\n\n\nexports.UTCTime = UTCTime;\n\nclass GeneralizedTime extends VisibleString {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"GeneralizedTime\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [value] String representatio of the date\r\n   * @property {Date} [valueDate] JavaScript \"Date\" object\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    this.millisecond = 0; //region Create UTCTime from ASN.1 UTC string value\n\n    if (\"value\" in parameters) {\n      this.fromString(parameters.value);\n      this.valueBlock.valueHex = new ArrayBuffer(parameters.value.length);\n      const view = new Uint8Array(this.valueBlock.valueHex);\n\n      for (let i = 0; i < parameters.value.length; i++) view[i] = parameters.value.charCodeAt(i);\n    } //endregion\n    //region Create GeneralizedTime from JavaScript Date type\n\n\n    if (\"valueDate\" in parameters) {\n      this.fromDate(parameters.valueDate);\n      this.valueBlock.valueHex = this.toBuffer();\n    } //endregion\n\n\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 24; // GeneralizedTime\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm === true ? inputLength : this.lenBlock.length);\n\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n\n    this.fromBuffer(this.valueBlock.valueHex);\n    if (this.idBlock.error.length === 0) this.blockLength += this.idBlock.blockLength;\n    if (this.lenBlock.error.length === 0) this.blockLength += this.lenBlock.blockLength;\n    if (this.valueBlock.error.length === 0) this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ArrayBuffer into ASN.1 internal string\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   */\n\n\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, new Uint8Array(inputBuffer)));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal string into ArrayBuffer\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n\n    for (let i = 0; i < str.length; i++) view[i] = str.charCodeAt(i);\n\n    return buffer;\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting \"Date\" object into ASN.1 internal string\r\n   * @param {!Date} inputDate JavaScript \"Date\" object\r\n   */\n\n\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n    this.millisecond = inputDate.getUTCMilliseconds();\n  } //**********************************************************************************\n  //noinspection JSUnusedGlobalSymbols\n\n  /**\r\n   * Function converting ASN.1 internal string into \"Date\" object\r\n   * @returns {Date}\r\n   */\n\n\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting JavaScript string into ASN.1 internal class\r\n   * @param {!string} inputString ASN.1 BER encoded array\r\n   */\n\n\n  fromString(inputString) {\n    //region Initial variables\n    let isUTC = false;\n    let timeString = \"\";\n    let dateTimeString = \"\";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0; //endregion\n    //region Convert as UTC time\n\n    if (inputString[inputString.length - 1] === \"Z\") {\n      timeString = inputString.substr(0, inputString.length - 1);\n      isUTC = true;\n    } //endregion\n    //region Convert as local time\n    else {\n        //noinspection JSPrimitiveTypeWrapperUsage\n        const number = new Number(inputString[inputString.length - 1]);\n        if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n        timeString = inputString;\n      } //endregion\n    //region Check that we do not have a \"+\" and \"-\" symbols inside UTC time\n\n\n    if (isUTC) {\n      if (timeString.indexOf(\"+\") !== -1) throw new Error(\"Wrong input string for convertion\");\n      if (timeString.indexOf(\"-\") !== -1) throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Get \"UTC time difference\" in case of local time\n    else {\n        let multiplier = 1;\n        let differencePosition = timeString.indexOf(\"+\");\n        let differenceString = \"\";\n\n        if (differencePosition === -1) {\n          differencePosition = timeString.indexOf(\"-\");\n          multiplier = -1;\n        }\n\n        if (differencePosition !== -1) {\n          differenceString = timeString.substr(differencePosition + 1);\n          timeString = timeString.substr(0, differencePosition);\n          if (differenceString.length !== 2 && differenceString.length !== 4) throw new Error(\"Wrong input string for convertion\"); //noinspection JSPrimitiveTypeWrapperUsage\n\n          let number = new Number(differenceString.substr(0, 2));\n          if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n          hourDifference = multiplier * number;\n\n          if (differenceString.length === 4) {\n            //noinspection JSPrimitiveTypeWrapperUsage\n            number = new Number(differenceString.substr(2, 2));\n            if (isNaN(number.valueOf())) throw new Error(\"Wrong input string for convertion\");\n            minuteDifference = multiplier * number;\n          }\n        }\n      } //endregion\n    //region Get position of fraction point\n\n\n    let fractionPointPosition = timeString.indexOf(\".\"); // Check for \"full stop\" symbol\n\n    if (fractionPointPosition === -1) fractionPointPosition = timeString.indexOf(\",\"); // Check for \"comma\" symbol\n    //endregion\n    //region Get fraction part\n\n    if (fractionPointPosition !== -1) {\n      //noinspection JSPrimitiveTypeWrapperUsage\n      const fractionPartCheck = new Number(`0${timeString.substr(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf())) throw new Error(\"Wrong input string for convertion\");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substr(0, fractionPointPosition);\n    } else dateTimeString = timeString; //endregion\n    //region Parse internal date\n\n\n    switch (true) {\n      case dateTimeString.length === 8:\n        // \"YYYYMMDD\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) throw new Error(\"Wrong input string for convertion\"); // Here we should not have a \"fraction point\"\n\n        break;\n\n      case dateTimeString.length === 10:\n        // \"YYYYMMDDHH\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 12:\n        // \"YYYYMMDDHHMM\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1000 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      case dateTimeString.length === 14:\n        // \"YYYYMMDDHHMMSS\"\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1000 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Wrong input string for convertion\");\n    } //endregion\n    //region Put parsed values at right places\n\n\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null) throw new Error(\"Wrong input string for convertion\");\n\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n\n        default:\n          throw new Error(\"Wrong input string for convertion\");\n      }\n    } //endregion\n    //region Get final date\n\n\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    } //endregion\n\n  } //**********************************************************************************\n\n  /**\r\n   * Function converting ASN.1 internal class into JavaScript string\r\n   * @returns {string}\r\n   */\n\n\n  toString() {\n    const outputArray = [];\n    outputArray.push((0, _pvutils.padNumber)(this.year, 4));\n    outputArray.push((0, _pvutils.padNumber)(this.month, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.day, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.hour, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.minute, 2));\n    outputArray.push((0, _pvutils.padNumber)(this.second, 2));\n\n    if (this.millisecond !== 0) {\n      outputArray.push(\".\");\n      outputArray.push((0, _pvutils.padNumber)(this.millisecond, 3));\n    }\n\n    outputArray.push(\"Z\");\n    return outputArray.join(\"\");\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"GeneralizedTime\";\n  } //**********************************************************************************\n\n  /**\r\n   * Convertion for the block to JSON object\r\n   * @returns {Object}\r\n   */\n\n\n  toJSON() {\n    let object = {}; //region Seems at the moment (Sep 2016) there is no way how to check method is supported in \"super\" object\n\n    try {\n      object = super.toJSON();\n    } catch (ex) {} //endregion\n\n\n    object.year = this.year;\n    object.month = this.month;\n    object.day = this.day;\n    object.hour = this.hour;\n    object.minute = this.minute;\n    object.second = this.second;\n    object.millisecond = this.millisecond;\n    return object;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.GeneralizedTime = GeneralizedTime;\n\nclass DATE extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DATE\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 31; // DATE\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DATE\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DATE = DATE;\n\nclass TimeOfDay extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"TimeOfDay\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 32; // TimeOfDay\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TimeOfDay\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.TimeOfDay = TimeOfDay;\n\nclass DateTime extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"DateTime\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 33; // DateTime\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"DateTime\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.DateTime = DateTime;\n\nclass Duration extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Duration\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 34; // Duration\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"Duration\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n\n/**\r\n * @extends Utf8String\r\n */\n\n\nexports.Duration = Duration;\n\nclass TIME extends Utf8String {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Time\" class\r\n   * @param {Object} [parameters={}]\r\n   */\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1; // UNIVERSAL\n\n    this.idBlock.tagNumber = 14; // Time\n  } //**********************************************************************************\n\n  /**\r\n   * Aux function, need to get a block name. Need to have it here for inhiritence\r\n   * @returns {string}\r\n   */\n\n\n  static blockName() {\n    return \"TIME\";\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Choice\n//**************************************************************************************\n\n\nexports.TIME = TIME;\n\nclass Choice {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Choice\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {Array} [value] Array of ASN.1 types for make a choice from\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", []);\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Any\n//**************************************************************************************\n\n\nexports.Choice = Choice;\n\nclass Any {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Any\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type Repeated\n//**************************************************************************************\n\n\nexports.Any = Any;\n\nclass Repeated {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.name = (0, _pvutils.getParametersValue)(parameters, \"name\", \"\");\n    this.optional = (0, _pvutils.getParametersValue)(parameters, \"optional\", false);\n    this.value = (0, _pvutils.getParametersValue)(parameters, \"value\", new Any());\n    this.local = (0, _pvutils.getParametersValue)(parameters, \"local\", false); // Could local or global array to store elements\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Declaration of special ASN.1 schema type RawData\n//**************************************************************************************\n\n/**\r\n * @description Special class providing ability to have \"toBER/fromBER\" for raw ArrayBuffer\r\n */\n\n\nexports.Repeated = Repeated;\n\nclass RawData {\n  //**********************************************************************************\n\n  /**\r\n   * Constructor for \"Repeated\" class\r\n   * @param {Object} [parameters={}]\r\n   * @property {string} [name]\r\n   * @property {boolean} [optional]\r\n   */\n  constructor(parameters = {}) {\n    this.data = (0, _pvutils.getParametersValue)(parameters, \"data\", new ArrayBuffer(0));\n  } //**********************************************************************************\n\n  /**\r\n   * Base function for converting block from BER encoded array of bytes\r\n   * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n   * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n   * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n   * @returns {number} Offset after least decoded byte\r\n   */\n\n\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.data = inputBuffer.slice(inputOffset, inputLength);\n    return inputOffset + inputLength;\n  } //**********************************************************************************\n\n  /**\r\n   * Encoding of current ASN.1 block into ASN.1 encoded array (BER rules)\r\n   * @param {boolean} [sizeOnly=false] Flag that we need only a size of encoding, not a real array of bytes\r\n   * @returns {ArrayBuffer}\r\n   */\n\n\n  toBER(sizeOnly = false) {\n    return this.data;\n  } //**********************************************************************************\n\n\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major ASN.1 BER decoding function\n//**************************************************************************************\n\n/**\r\n * Internal library function for decoding ASN.1 BER\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array\r\n * @param {!number} inputOffset Offset in ASN.1 BER encoded array where decoding should be started\r\n * @param {!number} inputLength Maximum length of array of bytes which can be using in this function\r\n * @returns {{offset: number, result: Object}}\r\n */\n\n\nexports.RawData = RawData;\n\nfunction LocalFromBER(inputBuffer, inputOffset, inputLength) {\n  const incomingOffset = inputOffset; // Need to store initial offset since \"inputOffset\" is changing in the function\n  //region Local function changing a type for ASN.1 classes\n\n  function localChangeType(inputObject, newType) {\n    if (inputObject instanceof newType) return inputObject;\n    const newObject = new newType();\n    newObject.idBlock = inputObject.idBlock;\n    newObject.lenBlock = inputObject.lenBlock;\n    newObject.warnings = inputObject.warnings; //noinspection JSCheckFunctionSignatures\n\n    newObject.valueBeforeDecode = inputObject.valueBeforeDecode.slice(0);\n    return newObject;\n  } //endregion\n  //region Create a basic ASN.1 type since we need to return errors and warnings from the function\n\n\n  let returnObject = new BaseBlock({}, Object); //endregion\n  //region Basic check for parameters\n\n  const baseBlock = new LocalBaseBlock();\n\n  if ((0, _pvutils.checkBufferParams)(baseBlock, inputBuffer, inputOffset, inputLength) === false) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Getting Uint8Array from ArrayBuffer\n\n\n  const intBuffer = new Uint8Array(inputBuffer, inputOffset, inputLength); //endregion\n  //region Initial checks\n\n  if (intBuffer.length === 0) {\n    this.error = \"Zero buffer length\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Decode indentifcation block of ASN.1 BER structure\n\n\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.idBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength; //endregion\n  //region Decode length block of ASN.1 BER structure\n\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  returnObject.warnings.concat(returnObject.lenBlock.warnings);\n\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength; //endregion\n  //region Check for usign indefinite length form in encoding for primitive types\n\n  if (returnObject.idBlock.isConstructed === false && returnObject.lenBlock.isIndefiniteForm === true) {\n    returnObject.error = \"Indefinite length form used for primitive encoding form\";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  } //endregion\n  //region Switch ASN.1 block type\n\n\n  let newASN1Type = BaseBlock;\n\n  switch (returnObject.idBlock.tagClass) {\n    //region UNIVERSAL\n    case 1:\n      //region Check for reserved tag numbers\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      } //endregion\n\n\n      switch (returnObject.idBlock.tagNumber) {\n        //region EndOfContent type\n        case 0:\n          //region Check for EndOfContent type\n          if (returnObject.idBlock.isConstructed === true && returnObject.lenBlock.length > 0) {\n            returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          } //endregion\n\n\n          newASN1Type = EndOfContent;\n          break;\n        //endregion\n        //region Boolean type\n\n        case 1:\n          newASN1Type = Boolean;\n          break;\n        //endregion\n        //region Integer type\n\n        case 2:\n          newASN1Type = Integer;\n          break;\n        //endregion\n        //region BitString type\n\n        case 3:\n          newASN1Type = BitString;\n          break;\n        //endregion\n        //region OctetString type\n\n        case 4:\n          newASN1Type = OctetString;\n          break;\n        //endregion\n        //region Null type\n\n        case 5:\n          newASN1Type = Null;\n          break;\n        //endregion\n        //region OBJECT IDENTIFIER type\n\n        case 6:\n          newASN1Type = ObjectIdentifier;\n          break;\n        //endregion\n        //region Enumerated type\n\n        case 10:\n          newASN1Type = Enumerated;\n          break;\n        //endregion\n        //region Utf8String type\n\n        case 12:\n          newASN1Type = Utf8String;\n          break;\n        //endregion\n        //region Time type\n        //region RELATIVE OBJECT IDENTIFIER type\n\n        case 13:\n          newASN1Type = RelativeObjectIdentifier;\n          break;\n        //endregion\n\n        case 14:\n          newASN1Type = TIME;\n          break;\n        //endregion\n        //region ASN.1 reserved type\n\n        case 15:\n          returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        //endregion\n        //region Sequence type\n\n        case 16:\n          newASN1Type = Sequence;\n          break;\n        //endregion\n        //region Set type\n\n        case 17:\n          newASN1Type = Set;\n          break;\n        //endregion\n        //region NumericString type\n\n        case 18:\n          newASN1Type = NumericString;\n          break;\n        //endregion\n        //region PrintableString type\n\n        case 19:\n          newASN1Type = PrintableString;\n          break;\n        //endregion\n        //region TeletexString type\n\n        case 20:\n          newASN1Type = TeletexString;\n          break;\n        //endregion\n        //region VideotexString type\n\n        case 21:\n          newASN1Type = VideotexString;\n          break;\n        //endregion\n        //region IA5String type\n\n        case 22:\n          newASN1Type = IA5String;\n          break;\n        //endregion\n        //region UTCTime type\n\n        case 23:\n          newASN1Type = UTCTime;\n          break;\n        //endregion\n        //region GeneralizedTime type\n\n        case 24:\n          newASN1Type = GeneralizedTime;\n          break;\n        //endregion\n        //region GraphicString type\n\n        case 25:\n          newASN1Type = GraphicString;\n          break;\n        //endregion\n        //region VisibleString type\n\n        case 26:\n          newASN1Type = VisibleString;\n          break;\n        //endregion\n        //region GeneralString type\n\n        case 27:\n          newASN1Type = GeneralString;\n          break;\n        //endregion\n        //region UniversalString type\n\n        case 28:\n          newASN1Type = UniversalString;\n          break;\n        //endregion\n        //region CharacterString type\n\n        case 29:\n          newASN1Type = CharacterString;\n          break;\n        //endregion\n        //region BmpString type\n\n        case 30:\n          newASN1Type = BmpString;\n          break;\n        //endregion\n        //region DATE type\n\n        case 31:\n          newASN1Type = DATE;\n          break;\n        //endregion\n        //region TimeOfDay type\n\n        case 32:\n          newASN1Type = TimeOfDay;\n          break;\n        //endregion\n        //region Date-Time type\n\n        case 33:\n          newASN1Type = DateTime;\n          break;\n        //endregion\n        //region Duration type\n\n        case 34:\n          newASN1Type = Duration;\n          break;\n        //endregion\n        //region default\n\n        default:\n          {\n            let newObject;\n            if (returnObject.idBlock.isConstructed === true) newObject = new Constructed();else newObject = new Primitive();\n            newObject.idBlock = returnObject.idBlock;\n            newObject.lenBlock = returnObject.lenBlock;\n            newObject.warnings = returnObject.warnings;\n            returnObject = newObject;\n            resultOffset = returnObject.fromBER(inputBuffer, inputOffset, inputLength);\n          }\n        //endregion\n      }\n\n      break;\n    //endregion\n    //region All other tag classes\n\n    case 2: // APPLICATION\n\n    case 3: // CONTEXT-SPECIFIC\n\n    case 4: // PRIVATE\n\n    default:\n      {\n        if (returnObject.idBlock.isConstructed === true) newASN1Type = Constructed;else newASN1Type = Primitive;\n      }\n    //endregion\n  } //endregion\n  //region Change type and perform BER decoding\n\n\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm === true ? inputLength : returnObject.lenBlock.length); //endregion\n  //region Coping incoming buffer for entire ASN.1 block\n\n  returnObject.valueBeforeDecode = inputBuffer.slice(incomingOffset, incomingOffset + returnObject.blockLength); //endregion\n\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n} //**************************************************************************************\n\n/**\r\n * Major function for decoding ASN.1 BER array into internal library structuries\r\n * @param {!ArrayBuffer} inputBuffer ASN.1 BER encoded array of bytes\r\n */\n\n\nfunction fromBER(inputBuffer) {\n  if (inputBuffer.byteLength === 0) {\n    const result = new BaseBlock({}, Object);\n    result.error = \"Input buffer has zero length\";\n    return {\n      offset: -1,\n      result\n    };\n  }\n\n  return LocalFromBER(inputBuffer, 0, inputBuffer.byteLength);\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major scheme verification function\n//**************************************************************************************\n\n/**\r\n * Compare of two ASN.1 object trees\r\n * @param {!Object} root Root of input ASN.1 object tree\r\n * @param {!Object} inputData Input ASN.1 object tree\r\n * @param {!Object} inputSchema Input ASN.1 schema to compare with\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction compareSchema(root, inputData, inputSchema) {\n  //region Special case for Choice schema element type\n  if (inputSchema instanceof Choice) {\n    const choiceResult = false;\n\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n\n      if (result.verified === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n\n    if (choiceResult === false) {\n      const _result = {\n        verified: false,\n        result: {\n          error: \"Wrong values for Choice type\"\n        }\n      };\n      if (inputSchema.hasOwnProperty(\"name\")) _result.name = inputSchema.name;\n      return _result;\n    }\n  } //endregion\n  //region Special case for Any schema element type\n\n\n  if (inputSchema instanceof Any) {\n    //region Add named component of ASN.1 schema\n    if (inputSchema.hasOwnProperty(\"name\")) root[inputSchema.name] = inputData; //endregion\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Initial check\n\n\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong root object\"\n      }\n    };\n  }\n\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 data\"\n      }\n    };\n  }\n\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"idBlock\" in inputSchema === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region Comparing idBlock properties in ASN.1 data and ASN.1 schema\n  //region Encode and decode ASN.1 schema idBlock\n  /// <remarks>This encoding/decoding is neccessary because could be an errors in schema definition</remarks>\n\n\n  if (\"fromBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (\"toBER\" in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  const encodedId = inputSchema.idBlock.toBER(false);\n\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error encoding idBlock for ASN.1 schema\"\n      }\n    };\n  }\n\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: {\n        error: \"Error decoding idBlock for ASN.1 schema\"\n      }\n    };\n  } //endregion\n  //region tagClass\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagClass\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region tagNumber\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"tagNumber\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isConstructed\n\n\n  if (inputSchema.idBlock.hasOwnProperty(\"isConstructed\") === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema\"\n      }\n    };\n  }\n\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region isHexOnly\n\n\n  if (\"isHexOnly\" in inputSchema.idBlock === false) // Since 'isHexOnly' is an inhirited property\n    {\n      return {\n        verified: false,\n        result: {\n          error: \"Wrong ASN.1 schema\"\n        }\n      };\n    }\n\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  } //endregion\n  //region valueHex\n\n\n  if (inputSchema.idBlock.isHexOnly === true) {\n    if (\"valueHex\" in inputSchema.idBlock === false) // Since 'valueHex' is an inhirited property\n      {\n        return {\n          verified: false,\n          result: {\n            error: \"Wrong ASN.1 schema\"\n          }\n        };\n      }\n\n    const schemaView = new Uint8Array(inputSchema.idBlock.valueHex);\n    const asn1View = new Uint8Array(inputData.idBlock.valueHex);\n\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  } //endregion\n  //endregion\n  //region Add named component of ASN.1 schema\n\n\n  if (inputSchema.hasOwnProperty(\"name\")) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n    if (inputSchema.name !== \"\") root[inputSchema.name] = inputData;\n  } //endregion\n  //region Getting next ASN.1 block for comparition\n\n\n  if (inputSchema.idBlock.isConstructed === true) {\n    let admission = 0;\n    let result = {\n      verified: false\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) maxLength = inputData.valueBlock.value.length;\n    } //region Special case when constructive value has no elements\n\n\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    } //endregion\n    //region Special case when \"inputData\" has no values and \"inputSchema\" has all optional values\n\n\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++) _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n\n      if (_optional === true) {\n        return {\n          verified: true,\n          result: root\n        };\n      } //region Delete early added name of block\n\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n        if (inputSchema.name !== \"\") delete root[inputSchema.name];\n      } //endregion\n\n\n      root.error = \"Inconsistent object length\";\n      return {\n        verified: false,\n        result: root\n      };\n    } //endregion\n\n\n    for (let i = 0; i < maxLength; i++) {\n      //region Special case when there is an \"optional\" element of ASN.1 schema at the end\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = \"Inconsistent length between ASN.1 data and schema\"; //region Delete early added name of block\n\n          if (inputSchema.hasOwnProperty(\"name\")) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n            if (inputSchema.name !== \"\") {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          } //endregion\n\n\n          return _result;\n        }\n      } //endregion\n      else {\n          //region Special case for Repeated type of ASN.1 schema element\n          if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n            result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n\n            if (result.verified === false) {\n              if (inputSchema.valueBlock.value[0].optional === true) admission++;else {\n                //region Delete early added name of block\n                if (inputSchema.hasOwnProperty(\"name\")) {\n                  inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                  if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                } //endregion\n\n\n                return result;\n              }\n            }\n\n            if (\"name\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n              let arrayRoot = {};\n              if (\"local\" in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local === true) arrayRoot = inputData;else arrayRoot = root;\n              if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\") arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n              arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n            }\n          } //endregion\n          else {\n              result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n\n              if (result.verified === false) {\n                if (inputSchema.valueBlock.value[i].optional === true) admission++;else {\n                  //region Delete early added name of block\n                  if (inputSchema.hasOwnProperty(\"name\")) {\n                    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n                    if (inputSchema.name !== \"\") delete root[inputSchema.name];\n                  } //endregion\n\n\n                  return result;\n                }\n              }\n            }\n        }\n    }\n\n    if (result.verified === false) // The situation may take place if last element is \"optional\" and verification failed\n      {\n        const _result = {\n          verified: false,\n          result: root\n        }; //region Delete early added name of block\n\n        if (inputSchema.hasOwnProperty(\"name\")) {\n          inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n          if (inputSchema.name !== \"\") {\n            delete root[inputSchema.name];\n            _result.name = inputSchema.name;\n          }\n        } //endregion\n\n\n        return _result;\n      }\n\n    return {\n      verified: true,\n      result: root\n    };\n  } //endregion\n  //region Ability to parse internal value for primitive-encoded value (value of OctetString, for example)\n\n\n  if (\"primitiveSchema\" in inputSchema && \"valueHex\" in inputData.valueBlock) {\n    //region Decoding of raw ASN.1 data\n    const asn1 = fromBER(inputData.valueBlock.valueHex);\n\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      }; //region Delete early added name of block\n\n      if (inputSchema.hasOwnProperty(\"name\")) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, \"\");\n\n        if (inputSchema.name !== \"\") {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      } //endregion\n\n\n      return _result;\n    } //endregion\n\n\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n\n  return {\n    verified: true,\n    result: root\n  }; //endregion\n} //**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * ASN.1 schema verification for ArrayBuffer data\r\n * @param {!ArrayBuffer} inputBuffer Input BER-encoded ASN.1 data\r\n * @param {!Object} inputSchema Input ASN.1 schema to verify against to\r\n * @return {{verified: boolean}|{verified:boolean, result: Object}}\r\n */\n\n\nfunction verifySchema(inputBuffer, inputSchema) {\n  //region Initial check\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: {\n        error: \"Wrong ASN.1 schema type\"\n      }\n    };\n  } //endregion\n  //region Decoding of raw ASN.1 data\n\n\n  const asn1 = fromBER(inputBuffer);\n\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  } //endregion\n  //region Compare ASN.1 struct with input schema\n\n\n  return compareSchema(asn1.result, asn1.result, inputSchema); //endregion\n} //**************************************************************************************\n//endregion\n//**************************************************************************************\n//region Major function converting JSON to ASN.1 objects\n//**************************************************************************************\n//noinspection JSUnusedGlobalSymbols\n\n/**\r\n * Converting from JSON to ASN.1 objects\r\n * @param {string|Object} json JSON string or object to convert to ASN.1 objects\r\n */\n\n\nfunction fromJSON(json) {} // TODO Implement\n//**************************************************************************************\n//endregion\n//**************************************************************************************\n//# sourceMappingURL=asn1.js.map","import { Any, compareSchema, ObjectIdentifier, Sequence } from \"asn1js\";\nimport { getParametersValue, clearProps } from \"pvutils\";\n//**************************************************************************************\n/**\n * Class from RFC5280\n */\nexport default class AlgorithmIdentifier {\n  //**********************************************************************************\n  /**\n   * Constructor for AlgorithmIdentifier class\n   * @param {Object} [parameters={}]\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\n   * @property {string} [algorithmId] ObjectIdentifier for algorithm (string representation)\n   */\n  constructor(parameters = {}) {\n    //region Internal properties of the object\n    /**\n     * @type {string}\n     * @desc ObjectIdentifier for algorithm (string representation)\n     */\n    this.algorithmId = getParametersValue(\n      parameters,\n      \"algorithmId\",\n      AlgorithmIdentifier.defaultValues(\"algorithmId\")\n    );\n\n    if (\"algorithmParams\" in parameters)\n      /**\n       * @type {Object}\n       * @desc Any algorithm parameters\n       */\n      this.algorithmParams = getParametersValue(\n        parameters,\n        \"algorithmParams\",\n        AlgorithmIdentifier.defaultValues(\"algorithmParams\")\n      );\n    //endregion\n\n    //region If input argument array contains \"schema\" for this object\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema);\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return \"\";\n      case \"algorithmParams\":\n        return new Any();\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Compare values with default values for all class members\n   * @param {string} memberName String name for a class member\n   * @param {*} memberValue Value to compare with default value\n   */\n  static compareWithDefault(memberName, memberValue) {\n    switch (memberName) {\n      case \"algorithmId\":\n        return memberValue === \"\";\n      case \"algorithmParams\":\n        return memberValue instanceof asn1js.Any;\n      default:\n        throw new Error(\n          `Invalid member name for AlgorithmIdentifier class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * AlgorithmIdentifier  ::=  Sequence  {\n   *    algorithm               OBJECT IDENTIFIER,\n   *    parameters              ANY DEFINED BY algorithm OPTIONAL  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} algorithmIdentifier ObjectIdentifier for the algorithm\n     * @property {string} algorithmParams Any algorithm parameters\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"\",\n      optional: names.optional || false,\n      value: [\n        new ObjectIdentifier({ name: names.algorithmIdentifier || \"\" }),\n        new Any({ name: names.algorithmParams || \"\", optional: true }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\"algorithm\", \"params\"]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(\n      schema,\n      schema,\n      AlgorithmIdentifier.schema({\n        names: {\n          algorithmIdentifier: \"algorithm\",\n          algorithmParams: \"params\",\n        },\n      })\n    );\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for AlgorithmIdentifier\"\n      );\n    //endregion\n\n    //region Get internal properties from parsed schema\n    this.algorithmId = asn1.result.algorithm.valueBlock.toString();\n    if (\"params\" in asn1.result) this.algorithmParams = asn1.result.params;\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convert current object to asn1js object and set correct values\n   * @returns {Object} asn1js object\n   */\n  toSchema() {\n    //region Create array for output sequence\n    const outputArray = [];\n\n    outputArray.push(new ObjectIdentifier({ value: this.algorithmId }));\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      outputArray.push(this.algorithmParams);\n    //endregion\n\n    //region Construct and return new ASN.1 schema for this object\n    return new Sequence({\n      value: outputArray,\n    });\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Convertion for the class to JSON object\n   * @returns {Object}\n   */\n  toJSON() {\n    const object = {\n      algorithmId: this.algorithmId,\n    };\n\n    if (\n      \"algorithmParams\" in this &&\n      this.algorithmParams instanceof asn1js.Any === false\n    )\n      object.algorithmParams = this.algorithmParams.toJSON();\n\n    return object;\n  }\n  //**********************************************************************************\n  /**\n   * Check that two \"AlgorithmIdentifiers\" are equal\n   * @param {AlgorithmIdentifier} algorithmIdentifier\n   * @returns {boolean}\n   */\n  isEqual(algorithmIdentifier) {\n    //region Check input type\n    if (algorithmIdentifier instanceof AlgorithmIdentifier === false)\n      return false;\n    //endregion\n\n    //region Check \"algorithm_id\"\n    if (this.algorithmId !== algorithmIdentifier.algorithmId) return false;\n    //endregion\n\n    //region Check \"algorithm_params\"\n    if (\"algorithmParams\" in this) {\n      if (\"algorithmParams\" in algorithmIdentifier)\n        return (\n          JSON.stringify(this.algorithmParams) ===\n          JSON.stringify(algorithmIdentifier.algorithmParams)\n        );\n\n      return false;\n    }\n\n    if (\"algorithmParams\" in algorithmIdentifier) return false;\n    //endregion\n\n    return true;\n  }\n  //**********************************************************************************\n}\n//**************************************************************************************\n","import {\n  BitString,\n  compareSchema,\n  Integer,\n  OctetString,\n  Sequence,\n} from \"asn1js\";\nimport { getParametersValue, clearProps, bufferToHexCodes } from \"pvutils\";\nimport AlgorithmIdentifier from \"./algorithm_identifier.js\";\n\nfunction ticket(parameters = {}) {\n  //TBSCertList  ::=  SEQUENCE  {\n  //    version                 Version OPTIONAL,\n  //                                 -- if present, MUST be v2\n  //    signature               AlgorithmIdentifier,\n  //    issuer                  Name,\n  //    thisUpdate              Time,\n  //    nextUpdate              Time OPTIONAL,\n  //    revokedCertificates     SEQUENCE OF SEQUENCE  {\n  //        userCertificate         CertificateSerialNumber,\n  //        revocationDate          Time,\n  //        crlEntryExtensions      Extensions OPTIONAL\n  //        -- if present, version MUST be v2\n  //    }  OPTIONAL,\n  //    crlExtensions           [0]  EXPLICIT Extensions OPTIONAL\n  //    -- if present, version MUST be v2\n  //}\n\n  /**\n   * @type {Object}\n   * @property {string} [blockName]\n   * @property {string} [tbsCertListVersion]\n   * @property {string} [signature]\n   * @property {string} [issuer]\n   * @property {string} [tbsCertListThisUpdate]\n   * @property {string} [tbsCertListNextUpdate]\n   * @property {string} [tbsCertListRevokedCertificates]\n   * @property {string} [crlExtensions]\n   */\n  const names = getParametersValue(parameters, \"names\", {});\n\n  return new Sequence({\n    name: names.blockName || \"ticket\",\n    value: [\n      new Integer({\n        name: names.ticketId || \"ticket.ticketId\",\n      }),\n      new Integer({\n        name: names.ticketClass || \"ticket.ticketClass\",\n      }),\n      new Integer({\n        name: names.conferenceId || \"ticket.conferenceId\",\n      }),\n      new OctetString({\n        optional: true,\n        name: names.co2_token || \"ticket.co2_token\",\n      }),\n      new OctetString({\n        name: names.riddle || \"ticket.riddle\",\n      })\n    ],\n  });\n}\n\nexport default class SignedTicket {\n  //**********************************************************************************\n  /**\n   * Constructor for Attribute class\n   * @param {Object} [parameters={}]\n   * @param {Object} [parameters.schema] asn1js parsed value to initialize the class from\n   */\n  constructor(parameters = {}) {\n    this.ticketId = getParametersValue(\n      parameters,\n      \"ticketId\",\n      SignedTicket.defaultValues(\"ticketId\")\n    );\n    this.ticketClass = getParametersValue(\n      parameters,\n      \"ticketClass\",\n      SignedTicket.defaultValues(\"ticketClass\")\n    );\n    this.conferenceId = getParametersValue(\n      parameters,\n      \"conferenceId\",\n      SignedTicket.defaultValues(\"conferenceId\")\n    );\n\tthis.riddle = getParametersValue(\n      parameters,\n      \"riddle\",\n      SignedTicket.defaultValues(\"riddle\")\n    );\n\n    //region If input argument array contains \"schema\" for this object\n    if (\"schema\" in parameters) this.fromSchema(parameters.schema);\n    //endregion\n  }\n  //**********************************************************************************\n  /**\n   * Return default values for all class members\n   * @param {string} memberName String name for a class member\n   */\n  static defaultValues(memberName) {\n    switch (memberName) {\n      case \"ticket\":\n        return 1;\n      case \"ticketId\":\n        return 1;\n      case \"ticketClass\":\n        return 1;\n      case \"conferenceId\":\n        return 1;\n\t  case \"riddle\":\n        return 1;\t\n      case \"signatureAlgorithm\":\n        return new AlgorithmIdentifier();\n\n      default:\n        throw new Error(\n          `Invalid member name for SignedTicket class: ${memberName}`\n        );\n    }\n  }\n  //**********************************************************************************\n  /**\n   * Return value of pre-defined ASN.1 schema for current class\n   *\n   * ASN.1 schema:\n   * ```asn1\n   * CertificateList  ::=  SEQUENCE  {\n   *    tbsCertList          TBSCertList,\n   *    signatureAlgorithm   AlgorithmIdentifier,\n   *    signatureValue       BIT STRING  }\n   * ```\n   *\n   * @param {Object} parameters Input parameters for the schema\n   * @returns {Object} asn1js schema object\n   */\n  static schema(parameters = {}) {\n    /**\n     * @type {Object}\n     * @property {string} [blockName]\n     * @property {string} [signatureAlgorithm]\n     * @property {string} [signatureValue]\n     */\n    const names = getParametersValue(parameters, \"names\", {});\n\n    return new Sequence({\n      name: names.blockName || \"SignedTicket\",\n      value: [\n        ticket(parameters),\n        AlgorithmIdentifier.schema(\n          names.signatureAlgorithm || {\n            names: {\n              blockName: \"signatureAlgorithm\",\n            },\n          }\n        ),\n        new BitString({\n          name: names.signatureValue || \"signatureValue\",\n        }),\n      ],\n    });\n  }\n  //**********************************************************************************\n  /**\n   * Convert parsed asn1js object into current class\n   * @param {!Object} schema\n   */\n  fromSchema(schema) {\n    //region Clear input data first\n    clearProps(schema, [\n      //   \"ticket\",\n      \"ticket.ticketId\",\n      \"ticket.ticketClass\",\n      \"ticket.conferenceId\",\n      \"ticket.co2_token\",\n      \"ticket.riddle\",\n      \"signatureAlgorithm\",\n      \"signatureValue\",\n    ]);\n    //endregion\n\n    //region Check the schema is valid\n    const asn1 = compareSchema(schema, schema, SignedTicket.schema());\n\n    if (asn1.verified === false)\n      throw new Error(\n        \"Object's schema was not verified against input data for SignedTicket\"\n      );\n\n    //endregion\n\n    //region Get internal properties from parsed schema\n    // noinspection JSUnresolvedVariable\n    this.ticket = asn1.result.ticket.valueBeforeDecode;\n\n    if (\"ticket.ticketId\" in asn1.result) {\n      const hex = bufferToHexCodes(\n        asn1.result[\"ticket.ticketId\"].valueBlock._valueHex\n      );\n\t  /* Big int does not work directly if we do not use hex conversion */\n      const ticketId = BigInt(`0x${hex}`);\n\n      this.ticketId = ticketId;\n\n      //   this.ticketId = asn1.result[\"ticket.ticketId\"].valueBlock.valueDec;\n    }\n\n    if (\"ticket.ticketClass\" in asn1.result)\n      this.ticketClass = asn1.result[\"ticket.ticketClass\"].valueBlock.valueDec;\n\n    if (\"ticket.conferenceId\" in asn1.result)\n      this.conferenceId =\n        asn1.result[\"ticket.conferenceId\"].valueBlock.valueDec;\n\n    // if (\"ticket.co2_token\" in asn1.result)\n    //   this.co2_token = asn1.result[\"ticket.co2_token\"].valueBlock.valueDec;\n\n    if (\"ticket.riddle\" in asn1.result)\n      this.riddle = asn1.result[\"ticket.riddle\"].valueBlock.valueDec;\n\n    this.signatureAlgorithm = new AlgorithmIdentifier({\n      schema: asn1.result.signatureAlgorithm,\n    });\n    this.signatureValue = asn1.result.signatureValue;\n    //endregion\n  }\n}\n","import { fromBER } from \"asn1js\";\nimport SignedTicket from \"./ticket_schema/ticket_schema\";\n\nlet asn1jsspan = document.querySelector(\"#asn1js\");\n\nexport function updateAsn1jsSpan(text) {\n  asn1jsspan.textContent = text;\n}\n\nexport function decode(inputContent) {\n  const der = Buffer.from(inputContent, \"base64\");\n\n  const ber = new Uint8Array(der).buffer;\n\n  const ans1 = fromBER(ber);\n\n  const ticket = new SignedTicket({\n    schema: ans1.result,\n  });\n\n  return ticket;\n}\n\nexport async function decodeAnsn1(input) {\n  const inputContent = input.value;\n\n  const result = decode(inputContent);\n  return result;\n}\n","import { decodeAnsn1, updateAsn1jsSpan } from \"./decoder\";\n\nconst input = document.getElementById(\"asn1js-coded-input\");\n\nconst handleFiles = async () => {\n\n  //   const base64 = await toBase64(selectedFile);\n  //   const result = decode(base64);\n  const { ticketClass, ticketId, conferenceId, riddle } = await decodeAnsn1(input);\n\n  const text = `ticketId = ${ticketId}, ticketClass = ${ticketClass}, conferenceId = ${conferenceId}, riddle = ${riddle}`;\n\n  updateAsn1jsSpan(text);\n};\n\ninput.addEventListener(\"change\", handleFiles);\n"],"names":["global","self","window","lookup","revLookup","Arr","Uint8Array","Array","inited","init","code","i","len","length","charCodeAt","encodeChunk","uint8","start","end","tmp","num","output","push","join","fromByteArray","extraBytes","parts","len2","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","value","c","rt","abs","isNaN","floor","log","LN2","toString","isArray","arr","call","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","__proto__","prototype","arg","encodingOrOffset","this","Error","allocUnsafe","from","TypeError","ArrayBuffer","array","byteOffset","byteLength","undefined","fromArrayLike","fromArrayBuffer","string","encoding","isEncoding","actual","slice","fromString","obj","internalIsBuffer","checked","copy","val","type","data","fromObject","assertSize","size","b","_isBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","bidirectionalIndexOf","dir","arrayIndexOf","indexOf","lastIndexOf","indexSize","arrLength","valLength","String","buf","readUInt16BE","foundIndex","found","j","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64.fromByteArray","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","fromCharCode","apply","decodeCodePointsArray","poolSize","_augment","alloc","fill","allocUnsafeSlow","isBuffer","isFastBuffer","readFloatLE","isSlowBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754.write","writeDouble","newBuf","subarray","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","ieee754.read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","INVALID_BASE64_RE","leadSurrogate","b64","l","placeHolders","L","base64.toByteArray","trim","replace","stringtrim","base64clean","src","dst","constructor","getParametersValue","parameters","name","defaultValue","Object","bufferToHexCodes","inputBuffer","inputOffset","inputLength","insertSpace","result","item","toUpperCase","utilFromBase","inputBase","utilToBase","base","reserved","internalReserved","internalValue","biggest","retBuf","retView","basis","base64Template","base64UrlTemplate","log2","clearProps","object","propsArray","prop","date","Date","getTime","getTimezoneOffset","baseBlock","error","buffers","outputLength","prevLength","views","view","valueHex","condition1","condition2","warnings","bigIntBuffer","bigIntView","bigInt","smallIntBuffer","smallIntView","modValue","tempBuf","tempView","k","inputBuffer1","inputBuffer2","view1","view2","inputNumber","fullLength","dif","padding","input","useUrlTemplate","skipPadding","skipLeadingZeros","flag1","flag2","template","nonZeroPosition","chr1","chr2","chr3","enc1","enc2","enc3","enc4","charAt","cutTailZeros","indexof","toSearch","test","incoming","nonZeroStart","resultString","element","stringLength","resultBuffer","resultView","round","defineProperty","exports","fromBER","compareSchema","inputSchema","verified","asn1","json","powers2","LocalBaseBlock","[object Object]","blockLength","_pvutils","valueBeforeDecode","blockName","HexBlock","BaseClass","super","isHexOnly","checkBufferParams","sizeOnly","ex","LocalIdentificationBlock","idBlock","tagClass","tagNumber","isConstructed","firstOctet","number","encodedBuf","encodedView","curView","intBuffer","tagNumberMask","count","tagNumberBufferMaxLength","intTagNumberBuffer","tempBuffer","tempBufferView","LocalLengthBlock","isIndefiniteForm","lenBlock","longFormUsed","lengthBufferView","ValueBlock","BaseBlock","valueBlockType","optional","primitiveSchema","valueBlock","resultOffset","idBlockBuf","toBER","valueBlockSizeBuf","lenBlockBuf","valueBlockBuf","utilConcatBuf","indefBuf","indefView","LocalPrimitiveValueBlock","valueHexView","Primitive","LocalConstructedValueBlock","initialOffset","initialLength","currentOffset","indefiniteLength","returnObject","LocalFromBER","EndOfContent","pop","valueBuf","Constructed","LocalEndOfContentValueBlock","paramaters","LocalBooleanValueBlock","utilDecodeTC","Boolean","Sequence","Set","Null","LocalOctetStringValueBlock","currentBlockName","OctetString","octetString","JSON","stringify","LocalBitStringValueBlock","unusedBits","BitString","bitString","LocalIntegerValueBlock","valueDec","_value","_valueHex","_valueDec","utilEncodeTC","expectedLength","updatedValueHex","updatedView","viewAdd","first","second","firstView","secondView","firstViewCopy","firstViewCopyLength","secondViewCopy","secondViewCopyLength","counter","utilConcatView","power2","p","digits","newValue","viewSub","firstBit","currentByte","bitNumber","asn1View","flag","byteNumber","Integer","otherValue","isEqualBuffer","integer","toDER","fromDER","Enumerated","LocalSidValueBlock","isFirstSid","tempValueHex","sidValue","LocalObjectIdentifierValueBlock","sidBlock","pos1","pos2","sid","plus","parsedSID","sidStr","sidArray","ObjectIdentifier","LocalUtf8StringValueBlock","Utf8String","fromBuffer","decodeURIComponent","escape","inputString","unescape","encodeURIComponent","LocalRelativeSidValueBlock","LocalRelativeObjectIdentifierValueBlock","RelativeObjectIdentifier","LocalBmpStringValueBlock","BmpString","copyBuffer","valueView","temp","Uint16Array","strLength","codeBuf","codeView","LocalUniversalStringValueBlock","UniversalString","Uint32Array","LocalSimpleStringValueBlock","LocalSimpleStringBlock","NumericString","PrintableString","TeletexString","VideotexString","IA5String","GraphicString","VisibleString","GeneralString","CharacterString","UTCTime","year","month","day","hour","minute","fromDate","valueDate","toBuffer","inputDate","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","UTC","parserArray","exec","outputArray","padNumber","GeneralizedTime","millisecond","getUTCMilliseconds","parser","isUTC","timeString","dateTimeString","fractionPart","hourDifference","minuteDifference","valueOf","multiplier","differencePosition","differenceString","fractionPointPosition","fractionPartCheck","fractionResult","tempDate","getUTCDay","DATE","TimeOfDay","DateTime","Duration","TIME","Choice","Any","Repeated","local","incomingOffset","newASN1Type","newObject","inputObject","newType","localChangeType","root","inputData","_result","hasOwnProperty","encodedId","schemaView","admission","maxLength","_optional","arrayRoot","AlgorithmIdentifier","algorithmId","defaultValues","algorithmParams","fromSchema","schema","memberName","memberValue","asn1js","names","algorithmIdentifier","algorithm","params","ticket","ticketId","ticketClass","conferenceId","co2_token","riddle","SignedTicket","signatureAlgorithm","signatureValue","hex","BigInt","asn1jsspan","document","querySelector","async","decodeAnsn1","inputContent","der","ber","ans1","decode","getElementById","addEventListener","text","textContent","updateAsn1jsSpan"],"mappings":"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"}